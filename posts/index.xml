<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on DaMuWang</title>
    <link>https://damuwangs.github.io/posts/</link>
    <description>Recent content in Posts on DaMuWang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Jun 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://damuwangs.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Vue2-nextTick</title>
      <link>https://damuwangs.github.io/posts/vue2-nexttick/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/vue2-nexttick/</guid>
      <description>概念  官方文档说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
 异步解析  Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新
 ​	简而言之，异步接信息的运行机制如下
 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack） 主线程之外，还存在一个&amp;quot;任务队列&amp;rdquo;（task queue）。只要异步任务有了运行结果，就在&amp;quot;任务队列&amp;quot;之中放置一个事件 一旦&amp;quot;执行栈&amp;quot;中的所有同步任务执行完毕，系统就会读取&amp;quot;任务队列&amp;rdquo;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行 主线程不断重复上面的第三步  事件循环说明 简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新
//改变数据vm.message = &#39;changed&#39;//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新console.log(vm.$el.textContent) // 并不会得到&#39;changed&#39;//这样可以，nextTick里面的代码会在DOM更新后执行Vue.nextTick(function(){console.log(vm.$el.textContent) // 可以得到&#39;changed&#39;})  本次更新循环
 首先修改数据，这是同步任务。同一事件循环的所有同步任务都在主线程上执行，形成一个执行栈，此时还未设计DOM Vue开启一个异步队列，并缓冲再次事件循环中发生的所有数据改变。如果同一个watcher被多次执行，只会被推入到队列中一次    下次更新循环
 同步任务执行完毕，开始执行异步watcher队列的任务，更新DOM。Vue在内部尝试对异步队列使用原生的Promise.then和messageChannel方法，如果执行环境不支持，会采用setTimeOut(fn,0)代替    下次更新循环结束之后
此时通过Vue.nextTick获取到改变后的DOM。通过setTimeOut(fn,0)也可以同样获取到
  简单总结事件循环：
 同步代码执行 查找异步队列，推入执行栈，执行Vue.nextTick[事件1] 查找异步队列，推入执行栈，执行Vue.nextTick[事件2]  总之，异步是单独的一个tick，不会和同步在同一个tick里发生，也是DOM不会马上改变的原有</description>
    </item>
    
    <item>
      <title>JavaScript-原型链</title>
      <link>https://damuwangs.github.io/posts/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <description>原型   理解原型对象 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。
使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中
function Person() {}Person.prototype.name = &#39;Nicholas&#39;Person.prototype.age = 19Person.prototype.sayName = function () {console.log(this.name)}let person1 = new Person()person1.sayName() // 输出：Nicholaslet person2 = new Person()person2.sayName() // 输出：Nicholasconsole.log(person1.sayName == person2.sayName) // 输出：true我们将sayName()方法和所有属性直接添加到Person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName()函数
创建了自定义构造函数之后，其原型对象默认只会取得constructor属性，至于其它方法，则都是从Object继承而来。当调用构造函数创建一个新实例后，该实例内部将包含一个指针（内部属性）____proto____指向构造函数的原型对象，需要明确的是，这个连接存在与实例和构造函数的原型之间，而不是存在与实例与构造函数之间
上图展示了Person构造函数、Person的原型属性以及Person现有两个实例之间的关系。在此，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其它属性。Person的每个实例person1和person2都包含一个内部属性____proto____，该属性仅仅指向了Person.prototype，换句话说，它们与构造函数没有直接关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName。这是通过查找对象属性的过程来实现的
  原型搜索机制 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象的实例本身开始。如果在实例中找到了具有给定名字的实现，则返回该属性的值，如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person.sayName()的时候，会先后执行两次搜索。首先，解析器会问：&amp;ldquo;实例person1有sayName属性吗？&amp;ldquo;答：&amp;ldquo;没有。&amp;ldquo;然后，它继续搜索，再问：&amp;ldquo;person1的原型有sayName属性吗？&amp;ldquo;答：&amp;ldquo;有。&amp;ldquo;于是，他就读取那个保存在原型对象中的函数。当我们调用person2.sayName()时，将会重现相同的搜索过程，得到相同的结果。而正是多个对象实例共享原型所保存的属性和方法的基本原理
  注意事项 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性
function Person() {}Person.prototype.name = &#39;Nicholas&#39;Person.prototype.age = 19Person.prototype.sayName = function () {console.</description>
    </item>
    
    <item>
      <title>JavaScript-闭包</title>
      <link>https://damuwangs.github.io/posts/javascript-%E9%97%AD%E5%8C%85/</link>
      <pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/javascript-%E9%97%AD%E5%8C%85/</guid>
      <description>概念   变量的作用域 要理解闭包，首先必须理解Javascript特殊的变量作用域
变量的作用域无非就是两种：全局变量和局部变量
Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量
var n=999function f1(){alert(n)}f1() // 999在函数外部无法读取函数内的局部变量
function f1(){var n=999}alert(n); // error  闭包的描述 闭包就是能够读取其他函数内部变量的函数
由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成&amp;quot;定义在一个函数内部的函数&amp;rdquo;
所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁，f2函数，就是闭包
function f1(){var n=999function f2(){alert(n)}return f2}var result = f1()result() // 999  闭包优缺点 优点：
  希望一个变量长期驻扎在内存中
  避免全局变量的污染
  私有成员的存在
  缺点：闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗
  应用场景   匿名自执行函数 我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包</description>
    </item>
    
    <item>
      <title>面试总结</title>
      <link>https://damuwangs.github.io/posts/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
      <description>JavaScript   跨域 概念：跨域指浏览器同源策略不允许当前页面所在的源去请求另一个源的数据只要协议，端口，域名中有一个不同就是跨域
解决：
 服务端更改header，允许跨域 设置代理服务器 因为客户端请求服务端的数据是存在跨域问题的，而服务器和服务器之间 可以相互请求数据，是没有跨域的概念（如果服务器没有设置禁止跨域的权限问题），也就是说，可以配置一个代理的服务器请求另一个服务器中的数据，然后把请求出来的数据返回到代理服务器中，代理服务器再返回数据给客户端，这样就可以实现跨域访问数据 jsonp 利用script标签的src属性来实现跨域。 通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。       get、post区别  get参数url可见，post参数url不可见 通过拼接url进行传递参数，post通过body体传递参数 get请求可以缓存，post请求不可以缓存 get请求页面后退时不产生影响、post请求页面后退时会重新提交请求 get一般传输数据大小不超过2k-4k，post请求传输数据的大小可配置       数据类型   单类型：String、Number、boolean、null、undefined
  引用类型：object、function、array、Date、RegExp
       值传递和引用传递   基本类型复制后两个变量完全独立，一方改变都不会影响另一方
  引用类型复制的时引用，之后的任何一方改变都会映射到另一方
       闭包 定义：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了父函数内部的变量，且返回的这个函数在外部被执行，就产生了闭包。说白了就是一个函数，能够读取其它函数的内部变量
优点：
 读取函数内部的变量 变量长期保存在内存中，不会再外层函数调用后被自动清除 避免全局变量的污染  缺点：常驻内存会增大内存使用量，使用不当会造成内存泄漏</description>
    </item>
    
    <item>
      <title>GitHub Pages&#43;Hugo构建个人博客</title>
      <link>https://damuwangs.github.io/posts/github-pages&#43;hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/github-pages&#43;hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>hugo配置 1、安装   下载地址：https://github.com/gohugoio/hugo/releases
  我使用的版本：  解压后即可使用hugo命令，不过只能在当前文件夹下使用，所以需要配置环境变量
  2、配置环境变量   在系统变量Path后面追加一条，为hugo.exe的解压地址我的在D盘
D:\hugo_0.83.1_Windows-64bit  3、项目创建   通过hugo命令创建站点目录并切换到该目录
hugo new site hugo-blogcd hugo-blog目录结构如下，此时如果运行的话浏览器会白屏，因为此时只是一个空的站点需要下载主题后才能看到内容
  4、主题配置   主题网站：https://themes.gohugo.io/
  我用的是这个主题：https://github.com/AmazingRise/hugo-theme-diary
  选好主题一般都会直接指向GitHub仓库，下载zip到本地就行
  将下载好的主题解压移动到项目目录下的themes文件夹
  配置站点根目录下的config.toml文件
我用的主题里面有作者提供的实例网站配置，把里面的内容复制到站点根目录的config.toml就完美运行了
这里需要注意config.toml配置的theme名称必须和themes下的文件夹名称保持一致
具体hugo的配置还没仔细研究，本篇就简单介绍一下大体的搭建流程，以后可能会写一篇hugo配置/开发相关的
  5、本地预览   启动 Hugo 预览服务器，构建站点内容到内存中并在检测到文件更改后重新渲染
hugo server  6、内容发布   在站点目录下有一个content文件夹，在该文件夹下创建一个posts，posts下创建.md格式的文章就可以自动识别发布了
  同理图片静态资源需要放在站点根目录static下，内容中图片引用也是以static为根目录进行读取的</description>
    </item>
    
  </channel>
</rss>