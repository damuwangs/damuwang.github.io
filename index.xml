<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DaMuWang</title>
    <link>https://damuwangs.github.io/</link>
    <description>Recent content on DaMuWang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 16 Jun 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://damuwangs.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>面试总结</title>
        <link>https://damuwangs.github.io/posts/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</link>
        <pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/ -&lt;h1 id=&#34;javascript&#34;&gt;javaScript&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;跨域&#34;&gt;跨域&lt;/h3&gt;
&lt;p&gt;概念：跨域指浏览器同源策略不允许当前页面所在的源去请求另一个源的数据只要协议，端口，域名中有一个不同就是跨域&lt;/p&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务端更改header，允许跨域&lt;/li&gt;
&lt;li&gt;设置代理服务器
因为客户端请求服务端的数据是存在跨域问题的，而服务器和服务器之间 可以相互请求数据，是没有跨域的概念（如果服务器没有设置禁止跨域的权限问题），也就是说，可以配置一个代理的服务器请求另一个服务器中的数据，然后把请求出来的数据返回到代理服务器中，代理服务器再返回数据给客户端，这样就可以实现跨域访问数据&lt;/li&gt;
&lt;li&gt;jsonp
利用script标签的src属性来实现跨域。 通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;getpost区别&#34;&gt;get、post区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;get参数url可见，post参数url不可见&lt;/li&gt;
&lt;li&gt;通过拼接url进行传递参数，post通过body体传递参数&lt;/li&gt;
&lt;li&gt;get请求可以缓存，post请求不可以缓存&lt;/li&gt;
&lt;li&gt;get请求页面后退时不产生影响、post请求页面后退时会重新提交请求&lt;/li&gt;
&lt;li&gt;get一般传输数据大小不超过2k-4k，post请求传输数据的大小可配置&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单类型：String、Number、boolean、null、undefined&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用类型：object、function、array、Date、RegExp&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;值传递和引用传递&#34;&gt;值传递和引用传递&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本类型复制后两个变量完全独立，一方改变都不会影响另一方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用类型复制的时引用，之后的任何一方改变都会映射到另一方&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;闭包&#34;&gt;闭包&lt;/h3&gt;
&lt;p&gt;定义：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了父函数内部的变量，且返回的这个函数在外部被执行，就产生了闭包。说白了就是一个函数，能够读取其它函数的内部变量&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取函数内部的变量&lt;/li&gt;
&lt;li&gt;变量长期保存在内存中，不会再外层函数调用后被自动清除&lt;/li&gt;
&lt;li&gt;避免全局变量的污染&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：常驻内存会增大内存使用量，使用不当会造成内存泄漏&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;箭头函数的好处&#34;&gt;箭头函数的好处&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简洁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不会改变this本来的绑定&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;事件的冒泡和捕获&#34;&gt;事件的冒泡和捕获&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1.png&#34; alt=&#34;事件冒泡&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;节流和防抖&#34;&gt;节流和防抖&lt;/h3&gt;
&lt;p&gt;防抖：防抖就是将一段时间内连续的多次触发转化为一次触发。一般可以使用在用户输入停止一段时间过后再去获取数据，而不是每次输入都去获取&lt;/p&gt;
&lt;p&gt;节流：高频事件触发，但在n秒内只会执行一次，如验证码登录时利用setTimeout做的倒计时&lt;/p&gt;
&lt;p&gt;区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;dom加载过程中ready和load的区别&#34;&gt;dom加载过程中ready和load的区别&lt;/h3&gt;
&lt;p&gt;Ready：页面HTML文档解析完成但图片等媒体文件加载完成之前执行
load：完全加载完成之后执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;字符串反转&#34;&gt;字符串反转&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC.jpg&#34; alt=&#34;字符串反转&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;slicesplice的区别&#34;&gt;slice、splice的区别&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/slice.jpg&#34; alt=&#34;slice&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/splice.jpg&#34; alt=&#34;splice&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;深拷贝和浅拷贝&#34;&gt;深拷贝和浅拷贝&lt;/h3&gt;
&lt;p&gt;概念：深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。&lt;/p&gt;
&lt;p&gt;浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。&lt;/p&gt;
&lt;p&gt;浅拷贝：assign()、concat()、slice()&lt;/p&gt;
&lt;p&gt;深拷贝：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;JSON.parse(JSON.stringify())&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手写递归方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E6%B7%B1%E6%8B%B7%E8%B4%9D.jpg&#34; alt=&#34;深拷贝&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;同步和异步&#34;&gt;同步和异步&lt;/h3&gt;
&lt;p&gt;同步：所有的任务都处在同一队列中，不可以插队，一个任务执行完接着开始执行下一个，相对于浏览器而言，同步的效率过低，一些耗费时间比较长的任务应该用异步来执行。&lt;/p&gt;
&lt;p&gt;异步：将一个任务放入到异步队列中，当这个任务执行完成之后，再从异步队列中提取出来，插队到同步队列中，拿到异步任务的结果，可以提升代码执行的效率，不需要因为一个耗时长的代码而一直等待&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;cookie-sessionstorage和localstorage&#34;&gt;cookie sessionStorage和localstorage&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;存储大小&lt;/p&gt;
&lt;p&gt;cookie数据大小不能超过4K&lt;/p&gt;
&lt;p&gt;sessionStorage和localStorage可以达到5M或更大&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有效时间&lt;/p&gt;
&lt;p&gt;localstorage：浏览器关闭后数据不丢失除非主动删除数据&lt;/p&gt;
&lt;p&gt;sessionStorage：数据在当前浏览器窗口关闭后自动删除&lt;/p&gt;
&lt;p&gt;cookie： 过期时间未到一直有效，即使窗口或浏览器关闭&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据与服务器之间的交互方式&lt;/p&gt;
&lt;p&gt;cookie：数据会自动传递到服务器，服务器也可以写cookie到客户端&lt;/p&gt;
&lt;p&gt;sessionStorage和localstorage：仅本地保存，不会发给服务端&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;判断一个字符串出现次数最多的字符统计这个次数&#34;&gt;判断一个字符串出现次数最多的字符，统计这个次数&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E7%BB%9F%E8%AE%A1%E6%9C%80%E5%A4%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E5%AD%97%E7%AC%A6.jpg&#34; alt=&#34;统计最多出现的字符&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;判断是不是数组&#34;&gt;判断是不是数组&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;instanceof&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/instanceof.jpg&#34; alt=&#34;instanceof&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;constructor&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/constructor.jpg&#34; alt=&#34;constructor&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Object.prototype.toString.call&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/prototype.jpg&#34; alt=&#34;prototype&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Array.isArray&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/isArray.jpg&#34; alt=&#34;isArray&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;promise&#34;&gt;Promise&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念：解决异步编程的一种方法，替代多层嵌套的回调，Promise是一个构造函数，用域封装异步操作并可以获得成功或失败的结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Promise all：将多个Promise实例包装成一个新的Promise实例，当所有状态都变成成功时all的状态才变为成功，如果其中一个状态为失败则返回失败结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行顺序问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Promise.jpg&#34; alt=&#34;Promise&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;原型链&#34;&gt;原型链&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;this指向&#34;&gt;this指向&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;ajax&#34;&gt;ajax&lt;/h3&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;小程序api&#34;&gt;小程序API&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;jquery选择器&#34;&gt;Jquery选择器&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
- https://damuwangs.github.io/posts/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/ - </description>
        </item>
    
    
    
        <item>
        <title>GitHub Pages&#43;Hugo构建个人博客</title>
        <link>https://damuwangs.github.io/posts/github-pages&#43;hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
        <pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/github-pages&#43;hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/github-pages&#43;hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ -&lt;h1 id=&#34;hugo配置&#34;&gt;hugo配置&lt;/h1&gt;
&lt;h3 id=&#34;1安装&#34;&gt;1、安装&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下载地址：&lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;https://github.com/gohugoio/hugo/releases&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我使用的版本：&lt;img src=&#34;https://damuwangs.github.io/img/GitHubPages+Hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hugo%E4%B8%8B%E8%BD%BD%E7%89%88%E6%9C%AC.png&#34; alt=&#34;hugo下载版本&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压后即可使用hugo命令，不过只能在当前文件夹下使用，所以需要配置环境变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/GitHubPages+Hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E6%9F%A5%E7%9C%8Bhugo%E7%89%88%E6%9C%AC.png&#34; alt=&#34;查看hugo版本&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2配置环境变量&#34;&gt;2、配置环境变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在系统变量Path后面追加一条，为hugo.exe的解压地址我的在D盘&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;D:\hugo_0.83.1_Windows-64bit
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3项目创建&#34;&gt;3、项目创建&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过hugo命令创建站点目录并切换到该目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo new site hugo-blog
cd hugo-blog
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;目录结构如下，此时如果运行的话浏览器会白屏，因为此时只是一个空的站点需要下载主题后才能看到内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/GitHubPages+Hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hugo%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png&#34; alt=&#34;hugo项目结构&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4主题配置&#34;&gt;4、主题配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主题网站：&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;https://themes.gohugo.io/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我用的是这个主题：&lt;a href=&#34;https://github.com/AmazingRise/hugo-theme-diary&#34;&gt;https://github.com/AmazingRise/hugo-theme-diary&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选好主题一般都会直接指向GitHub仓库，下载zip到本地就行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将下载好的主题解压移动到项目目录下的themes文件夹&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置站点根目录下的config.toml文件&lt;/p&gt;
&lt;p&gt;我用的主题里面有作者提供的实例网站配置，把里面的内容复制到站点根目录的config.toml就完美运行了&lt;/p&gt;
&lt;p&gt;这里需要注意config.toml配置的theme名称必须和themes下的文件夹名称保持一致&lt;/p&gt;
&lt;p&gt;&lt;code&gt;具体hugo的配置还没仔细研究，本篇就简单介绍一下大体的搭建流程，以后可能会写一篇hugo配置/开发相关的&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5本地预览&#34;&gt;5、本地预览&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动 Hugo 预览服务器，构建站点内容到内存中并在检测到文件更改后重新渲染&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo server
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6内容发布&#34;&gt;6、内容发布&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在站点目录下有一个content文件夹，在该文件夹下创建一个posts，posts下创建.md格式的文章就可以自动识别发布了&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/GitHubPages+Hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hugo%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%842.png&#34; alt=&#34;hugo项目结构2&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同理图片静态资源需要放在站点根目录static下，内容中图片引用也是以static为根目录进行读取的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;目前没有处理图片在typora中不能显示，只能在网页预览站点中显示的问题&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;github配置&#34;&gt;GitHub配置&lt;/h1&gt;
&lt;h3 id=&#34;1创建仓库&#34;&gt;1、创建仓库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建一个新仓库，仓库需要命名为xxx.github.io，一个账户只能创建一个GitHub Pages&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/GitHubPages+Hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE.png&#34; alt=&#34;创建博客项目&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建好之后顶部点击settings，左侧菜单栏选择pages，点击choose a theme选择一个官方指定主题&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/GitHubPages+Hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE2.png&#34; alt=&#34;创建博客项目2&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择完主题后，访问仓库名就可以访问GitHub Pages主页了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2github加速&#34;&gt;2、GitHub加速&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;因为同步GitHub经常会出现网络超时的错误，所以在谷歌找了个GitHub加速插件&lt;/p&gt;
&lt;p&gt;这个插件就是在GitHub仓库下载旁边新增了一个加速的按钮，选择国内镜像的仓库地址就不会出现网络超时的问题了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插件地址：&lt;a href=&#34;https://chrome.google.com/webstore/detail/github%E5%8A%A0%E9%80%9F/mfnkflidjnladnkldfonnaicljppahpg&#34;&gt;https://chrome.google.com/webstore/detail/github%E5%8A%A0%E9%80%9F/mfnkflidjnladnkldfonnaicljppahpg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub地址：&lt;a href=&#34;https://github.com/fhefh2015/Fast-GitHub&#34;&gt;https://github.com/fhefh2015/Fast-GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3提交和版本同步&#34;&gt;3、提交和版本同步&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进入站点根目录执行命令执行编译，创建public目录生成静态html项目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 默认在当前文件夹下生成public文件夹
hugo
# 参数d可以自定义生成路径
hugo -d ../damuwangs.github.io
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将生成后的静态html项目提交到xxx.github.io仓库，访问xxx.github.io就可以看到更新好的网页了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.waynerv.com/posts/setup-blog-with-hugo-and-github-pages&#34;&gt;https://www.waynerv.com/posts/setup-blog-with-hugo-and-github-pages&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/github-pages&#43;hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ - </description>
        </item>
    
    
  </channel>
</rss> 