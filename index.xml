<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DaMuWang</title>
    <link>https://damuwangs.github.io/</link>
    <description>Recent content on DaMuWang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Feb 2022 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://damuwangs.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Vue2-权限控制</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</link>
        <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/ -&lt;h1 id=&#34;权限配置&#34;&gt;权限配置&lt;/h1&gt;
&lt;h2 id=&#34;devtools&#34;&gt;devTools&lt;/h2&gt;
&lt;p&gt;是一个独立部署的前端权限，接口配置工具。主要分为四层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平台Platform：确保此工具可以跨项目使用，不用每一个项目再部署一套&lt;/li&gt;
&lt;li&gt;系统system：每个平台下的左侧系统，一般同一个类型的功能会放在一个系统里&lt;/li&gt;
&lt;li&gt;菜单menu：点击后跳转页面的具体菜单&lt;/li&gt;
&lt;li&gt;功能function：主要指页面上的操作按钮，这里会配置对应的后台服务和接口名称&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在devTools依次维护平台、系统、菜单和功能项&lt;/li&gt;
&lt;li&gt;系统会预留一个拥有所有权限的管理账户&lt;/li&gt;
&lt;li&gt;登录管理员账户进入系统管理功能新增角色，权限会以树的形式进行多选展示&lt;/li&gt;
&lt;li&gt;进入员工管理功能录入基本信息，角色信息会以一个多选的checkbox进行勾选&lt;/li&gt;
&lt;li&gt;将创建好的员工分配给具体用户&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;权限实现&#34;&gt;权限实现&lt;/h1&gt;
&lt;p&gt;用户登录成功时会调用GetMenuInfo，获取当前登录账户的所有权限，并将权限放入全局状态和缓存&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @description: 查询当前登录用户权限数据
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @param {object} data 登录返回token
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @return {promise}
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; */&lt;/span&gt;
GetMenuInfo&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; ({ commit }, data) =&amp;gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; subData &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
        	&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;tk&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; data.v.token
      	}
      	&lt;span style=&#34;color:#6272a4&#34;&gt;// 请求服务端返回当前登录用户的权限数据
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;      	base.getMenuInfo(subData).then(response =&amp;gt; {
        	&lt;span style=&#34;color:#6272a4&#34;&gt;// 保存system到state中
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;        	commit(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;SET_SYSTEMS&amp;#39;&lt;/span&gt;, response.data.v.SystemList)
        	storage.setLocalStorage(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;SYSTEMS&amp;#39;&lt;/span&gt;, response.data.v.SystemList)
        	&lt;span style=&#34;color:#6272a4&#34;&gt;// 保存menu到state中
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;        	commit(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;SET_MENUS&amp;#39;&lt;/span&gt;, response.data.v.MenuList)
        	storage.setLocalStorage(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;MENUS&amp;#39;&lt;/span&gt;, response.data.v.MenuList)
        	&lt;span style=&#34;color:#6272a4&#34;&gt;// 保存function到state中
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;        	commit(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;SET_FUNCTIONS&amp;#39;&lt;/span&gt;, response.data.v.FunctionList)
        	storage.setLocalStorage(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;FUNCTIONS&amp;#39;&lt;/span&gt;, response.data.v.FunctionList)
        	resolve()
     	 }).&lt;span style=&#34;color:#ff79c6&#34;&gt;catch&lt;/span&gt;(error =&amp;gt; {
        	reject(error)
      	})
    })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;退出时会清空所有全局状态和缓存&lt;/p&gt;
&lt;h2 id=&#34;菜单权限&#34;&gt;菜单权限&lt;/h2&gt;
&lt;p&gt;系统左侧菜单用的element_ui的menu导航&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&amp;lt;!--router：使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转--&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;el-menu&lt;/span&gt;
    &lt;span style=&#34;color:#50fa7b&#34;&gt;:default-active&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;activeIndex&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#50fa7b&#34;&gt;:collapse&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;toggle&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#50fa7b&#34;&gt;mode&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;vertical&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#50fa7b&#34;&gt;router&lt;/span&gt;
    &lt;span style=&#34;color:#50fa7b&#34;&gt;:unique-opened&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#50fa7b&#34;&gt;:collapse-transition&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt;
&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;submenu&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;:menu&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;menuData&amp;#34;&lt;/span&gt; /&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;el-menu&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里从全局中获取菜单数据并组合成如下格式，也就是menuData传给子组件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;SysId&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;AirTickets&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;SysName&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;机票&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;PlatFormType&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;ManagementSystems&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;SortNo&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#bd93f9&#34;&gt;20&lt;/span&gt;,
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;DefaultIcon&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;sxiconmg-flight&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;DefaultUrl&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;http://localhost:8080/&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;path&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;/AirTickets&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;机票&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;children&amp;#34;&lt;/span&gt;:[
            {
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;SysId&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;AirTickets&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;MenuId&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;AirTicketsOrder&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;MenuName&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;机票订单&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;ParentId&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;SortNo&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;10&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;path&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;AirTicketsOrder&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;机票订单&amp;#34;&lt;/span&gt;
            },
            {
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;SysId&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;AirTickets&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;MenuId&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;AirticketsAnalysis&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;MenuName&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;票号解析&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;ParentId&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;SortNo&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;path&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;AirticketsAnalysis&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;票号解析&amp;#34;&lt;/span&gt;
            }
        ]
    },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在子组件中递归显示所有子菜单&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;template&lt;/span&gt;&amp;gt;
	&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;menu-wrapper&amp;#34;&lt;/span&gt;&amp;gt;
    	&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;v-for&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;item in menu&amp;#34;&lt;/span&gt;&amp;gt;
	    	&lt;span style=&#34;color:#6272a4&#34;&gt;&amp;lt;!-- 只有一级菜单 --&amp;gt;&lt;/span&gt;
      		&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;el-menu-item&lt;/span&gt;
        		&lt;span style=&#34;color:#50fa7b&#34;&gt;v-if&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;!item.children &amp;amp;&amp;amp; !item.hidden&amp;#34;&lt;/span&gt;
        		&lt;span style=&#34;color:#50fa7b&#34;&gt;:key&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;item.path&amp;#34;&lt;/span&gt;
        		&lt;span style=&#34;color:#50fa7b&#34;&gt;:index&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;parent ? parent + &amp;#39;/&amp;#39; + item.path : item.path&amp;#34;&lt;/span&gt;
      		&amp;gt;
        		&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;:class&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[&amp;#39;iconfont&amp;#39;, item.DefaultIcon]&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;i&lt;/span&gt;&amp;gt;
        		&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;span&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;slot&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;title&amp;#34;&lt;/span&gt;&amp;gt;{{ item.name }}&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;span&lt;/span&gt;&amp;gt;
			&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;el-menu-item&lt;/span&gt;&amp;gt;
			&lt;span style=&#34;color:#6272a4&#34;&gt;&amp;lt;!-- 多级菜单 --&amp;gt;&lt;/span&gt;
			&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;el-submenu&lt;/span&gt;
				&lt;span style=&#34;color:#50fa7b&#34;&gt;v-if&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;item.children &amp;amp;&amp;amp; !item.hidden&amp;#34;&lt;/span&gt;
				&lt;span style=&#34;color:#50fa7b&#34;&gt;:key&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;item.path&amp;#34;&lt;/span&gt;
				&lt;span style=&#34;color:#50fa7b&#34;&gt;:index&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;parent ? parent + &amp;#39;/&amp;#39; + item.path : item.path&amp;#34;&lt;/span&gt;
              &amp;gt;
				&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;slot&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;title&amp;#34;&lt;/span&gt;&amp;gt;
					&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;:class&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[&amp;#39;iconfont&amp;#39;, item.DefaultIcon]&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;i&lt;/span&gt;&amp;gt;
					&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;span&lt;/span&gt;&amp;gt;{{ item.name }}&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;span&lt;/span&gt;&amp;gt;
				&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;template&lt;/span&gt;&amp;gt;
				&lt;span style=&#34;color:#6272a4&#34;&gt;&amp;lt;!-- 递归 --&amp;gt;&lt;/span&gt;
				&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;sidebar-item&lt;/span&gt;
					&lt;span style=&#34;color:#50fa7b&#34;&gt;:menu&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;item.children&amp;#34;&lt;/span&gt;
					&lt;span style=&#34;color:#50fa7b&#34;&gt;:parent&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;parent ? parent + &amp;#39;/&amp;#39; + item.path : item.path&amp;#34;&lt;/span&gt;
				/&amp;gt;
			&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;el-submenu&lt;/span&gt;&amp;gt;
    	&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;template&lt;/span&gt;&amp;gt;
  	&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;template&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;预览如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/Vue2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/%E5%B7%A6%E4%BE%A7%E8%8F%9C%E5%8D%95.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;按钮权限&#34;&gt;按钮权限&lt;/h2&gt;
&lt;p&gt;公共方法中提供了过滤当前所在功能按钮权限的方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @description: 数组过滤（匹配某菜单下所有方法）
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @param {string} sysId 系统ID
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @param {string} menuId 菜单ID
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @return {array} 某一菜单下的所有Function
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; filterarr &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; (sysId, menuId) {
  &lt;span style=&#34;color:#6272a4&#34;&gt;// 获取缓存中所有的FUNCTION
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; array &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; JSON.parse(localStorage.getItem(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;management-FUNCTIONS&amp;#39;&lt;/span&gt;)) &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; []
  &lt;span style=&#34;color:#6272a4&#34;&gt;// 根据传入系统和菜单唯一标识，返回当前功能的所有按钮
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; newArr &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; array.filter(item =&amp;gt; {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; item.SysId &lt;span style=&#34;color:#ff79c6&#34;&gt;===&lt;/span&gt; sysId &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; item.MenuId &lt;span style=&#34;color:#ff79c6&#34;&gt;===&lt;/span&gt; menuId
  })
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; newArr
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里以系统中任一功能演示&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @description: 绑定当前功能页面的按钮权限
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @param {*}
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @return {*}
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; */&lt;/span&gt;
getFunc () {
	&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; pagefunc &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; filterarr(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;SysManagement&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;EmployeeManagement&amp;#39;&lt;/span&gt;)
    pagefunc.forEach((item) =&amp;gt; {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (item.FunctionId &lt;span style=&#34;color:#ff79c6&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;SaveEmployee&amp;#39;&lt;/span&gt;) {
            &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.isAddFuc &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// 新增按钮是否显示
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.addFuc &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; item &lt;span style=&#34;color:#6272a4&#34;&gt;// 新增api信息
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;        }
        &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (item.FunctionId &lt;span style=&#34;color:#ff79c6&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;UpdateEmployee&amp;#39;&lt;/span&gt;) {
            &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.isUpdateFuc &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// 修改按钮是否显示
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.updateFuc &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; item &lt;span style=&#34;color:#6272a4&#34;&gt;// 修改api信息
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;        }
        &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (item.FunctionId &lt;span style=&#34;color:#ff79c6&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;GetEmployeeEntity&amp;#39;&lt;/span&gt;) {
            &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.isViewFuc &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// 查看按钮是否显示
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.viewFuc &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; item &lt;span style=&#34;color:#6272a4&#34;&gt;// 查看api信息
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;        }
    })
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;按钮显示需要加上v-if判断权限&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;el-button&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;v-if&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;isAddFuc&amp;#34;&lt;/span&gt; @&lt;span style=&#34;color:#50fa7b&#34;&gt;click&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;bindEdit(&amp;#39;add&amp;#39;)&amp;#34;&lt;/span&gt;&amp;gt;添加&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;el-button&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发送请求时不用重新定义api&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @description: 查询当前登录用户权限数据
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @param {object} data 接口请求参数
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @param {string} ServiceName 接口服务名称（一个平台对应一个服务）
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @param {string} ApiName 接口名称
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @return {*}
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; */&lt;/span&gt;
base.commonFuc(data, &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.addFuc.ServiceName, &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.addFuc.ApiName).then((res) =&amp;gt; {
    ...
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;注意&#34;&gt;注意&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;权限菜单的跳转是根据系统和菜单维护的编号与router中配置的路由匹配的，需要保持一致&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000012861862&#34;&gt;Vue.nextTick 的原理和用途&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/ - </description>
        </item>
    
    
    
        <item>
        <title>【待补充】Vue2-框架搭建</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</link>
        <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/ -&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;官方文档说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000012861862&#34;&gt;Vue.nextTick 的原理和用途&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/ - </description>
        </item>
    
    
    
        <item>
        <title>【待补充】Vue3-和Vue2的区别</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-%E5%92%8Cvue2%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
        <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-%E5%92%8Cvue2%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-%E5%92%8Cvue2%E7%9A%84%E5%8C%BA%E5%88%AB/ -&lt;h1 id=&#34;优势&#34;&gt;优势&lt;/h1&gt;
&lt;h1 id=&#34;不同&#34;&gt;不同&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;官方文档说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000012861862&#34;&gt;Vue.nextTick 的原理和用途&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-%E5%92%8Cvue2%E7%9A%84%E5%8C%BA%E5%88%AB/ - </description>
        </item>
    
    
    
        <item>
        <title>面试-2022年3月</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/%E9%9D%A2%E8%AF%95-2022%E5%B9%B43%E6%9C%88/</link>
        <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/%E9%9D%A2%E8%AF%95-2022%E5%B9%B43%E6%9C%88/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/%E9%9D%A2%E8%AF%95-2022%E5%B9%B43%E6%9C%88/ -&lt;h1 id=&#34;javascript&#34;&gt;JavaScript&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;移动端事件延迟&#34;&gt;移动端事件延迟&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_45516629/article/details/105053755&#34;&gt;移动端点击（click）事件延迟问题的解决方法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;前端路由的理解&#34;&gt;前端路由的理解&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/29fb3ec0611c&#34;&gt;关于前端路由的一点理解&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;promise&#34;&gt;Promise&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../javascript-%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#promise&#34;&gt;JavaScript-异步解决方案-Promise&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Promise 可不可以中断？&lt;/p&gt;
&lt;p&gt;严格的说不能中断，但可以借助 pending 和 reject 来达到中断效果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有一个业务，需要发出两个不同的异步请求，得到所有结果后才去走下一步业务逻辑，如果用 Promise做的话，咋做？&lt;/p&gt;
&lt;p&gt;尽量别用Promise.all()，推荐使用 Promise.allSettled()方法&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/c6f49d9b7e8d&#34;&gt;Promise.all &amp;amp; Promise.allSettled&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;es6&#34;&gt;ES6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/6fa57c2d5a5c&#34;&gt;前端基础：ES6+ 常用语法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;css&#34;&gt;Css&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;flex布局&#34;&gt;flex布局&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&#34;&gt;Flex 布局教程：语法篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2015/07/flex-examples.html&#34;&gt;Flex 布局教程：实例篇&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;媒体查询&#34;&gt;媒体查询&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/css3/css3-mediaqueries.html&#34;&gt;CSS3 多媒体查询&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;元素浮动&#34;&gt;元素浮动&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/css/css-float.html&#34;&gt;CSS Float(浮动)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;什么时候会出现元素的浮动现象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;js动画css动画&#34;&gt;JS动画、CSS动画&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/css3/css3-animations.html&#34;&gt;CSS3 动画&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的思路：JS动画复杂，适合做精确控制的大型特效。CSS动画简单，适合做小小的展示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;canvas-画布&#34;&gt;canvas 画布&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/html/html5-canvas.html&#34;&gt;HTML5 Canvas&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vue&#34;&gt;Vue&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;生命周期的理解&#34;&gt;生命周期的理解&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/672e967e201c&#34;&gt;Vue - 生命周期详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E9%9D%A2%E8%AF%95-2022%E5%B9%B43%E6%9C%88/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;为啥vue的属性要写成函数的形式而不是对象的形式&#34;&gt;为啥Vue的属性要写成函数的形式而不是对象的形式&lt;/h2&gt;
&lt;p&gt;Vue根实例是单例，data 属性可以是对象写法或函数写法，但组件里的 data只能采用函数写法。&lt;/p&gt;
&lt;p&gt;因为直接创建的对象，只有独一份数据，不同父组件使用时，一定会出现数据混乱。而函数返回的对象，每次返回的是不同的对象，不会出现数据污染。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;给对象添加一个新属性时页面不刷新咋办&#34;&gt;给对象添加一个新属性时，页面不刷新咋办&lt;/h2&gt;
&lt;p&gt;我的思路：Vue.set()方法，Object.assign() 方法，还有 forceUpdate()方法。&lt;/p&gt;
&lt;p&gt;说明：它们底层调用的其实都是 ES5 的Object.defineProperty() 方法，采用get、set方式实现的数据响应化，不过这种方式有天然缺陷，只能对单个属性进行监听。而当对象新增key、删除key、数组内部变化时，此时监听不到，Vue无法响应，页面刷新失灵。Vue2本身专门打了补丁解决这个问题，但解决的并不好。这是Vue2本身的设计缺陷，Vue3不存在这个问题，因为Vue3采用了Proxy代理的方式实现数据响应化，对对象整体进行监听，可以实现深层监听。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;vue解决跨域&#34;&gt;Vue解决跨域&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000016199721&#34;&gt;webpack开发配置API代理解决跨域问题-devServer&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;vue项目权限控制&#34;&gt;Vue项目权限控制&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../vue2-token&#34;&gt;Vue2-token&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../vue2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6&#34;&gt;Vue2-权限控制&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;vue代码里key的作用是啥&#34;&gt;Vue代码里，key的作用是啥&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;key 的作用主要是为了高效的更新虚拟 DOM。另外 vue 中在使用相同标签 名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们。否则 vue 只会替换其内部属性而不会触发过渡效果&lt;/li&gt;
&lt;li&gt;key 不能用 index 代替，index 在同一个页面会有重复的情况，违背了高效&lt;a href=&#34;https://www.zhihu.com/search?q=%E6%B8%B2%E6%9F%93&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A441397069%7D&#34;&gt;渲染&lt;/a&gt;的初衷。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;vue3比-vue2好在哪里&#34;&gt;Vue3比 Vue2好在哪里&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../vue3-%E5%92%8Cvue2%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;Vue3-和Vue2的区别&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;对vue-router的理解&#34;&gt;对Vue-Router的理解&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/q879936814/article/details/103028992?spm=1001.2101.3001.6661.1&amp;amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;amp;utm_relevant_index=1&#34;&gt;vue-router基本理解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vue Router是Vue.js的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;嵌套路由映射&lt;/li&gt;
&lt;li&gt;动态路由选择&lt;/li&gt;
&lt;li&gt;模块化、基于组件的路由配置&lt;/li&gt;
&lt;li&gt;路由参数、查询、通配符&lt;/li&gt;
&lt;li&gt;路由守卫&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;项目里面怎么用-axios&#34;&gt;项目里面怎么用 axios&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codepen.io/damuwangs/pen/ExXGmww&#34;&gt;Vue-Demo-使用axios封装Http工具类&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;mvvm的理解&#34;&gt;MVVM的理解&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../javascript-mvcmvvm%E6%A8%A1%E5%BC%8F&#34;&gt;JavaScript-MVC、MVVM模式&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;其它&#34;&gt;其它&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;webpack构建流程&#34;&gt;webpack构建流程&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kdocs.cn/l/sqBhRGjkFOYm&#34;&gt;webpack&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;git-和svn的区别&#34;&gt;Git 和SVN的区别&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;tcp的三次握手四次挥手&#34;&gt;TCP的三次握手、四次挥手&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;前端安全漏洞攻击吗&#34;&gt;前端安全漏洞攻击吗&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_45516629/article/details/105053755&#34;&gt;移动端点击（click）事件延迟问题的解决方法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/%E9%9D%A2%E8%AF%95-2022%E5%B9%B43%E6%9C%88/ - </description>
        </item>
    
    
    
        <item>
        <title>【待补充】React-Hook</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-hook/</link>
        <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-hook/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-hook/ -&lt;h1 id=&#34;为什么需要portals&#34;&gt;为什么需要Portals&lt;/h1&gt;
&lt;p&gt;Portals能够将子组件渲染到父组件以外的DOM树，他通常用于子组件需要从父组件的容器中脱离出来的场景，有以下场景：&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/29880992&#34;&gt;传送门：React Portal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6892951045685641224&#34;&gt;你真的了解React Portals吗&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-hook/ - </description>
        </item>
    
    
    
        <item>
        <title>【待补充】React-RenderProps</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-renderprops/</link>
        <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-renderprops/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-renderprops/ -&lt;h1 id=&#34;为什么需要portals&#34;&gt;为什么需要Portals&lt;/h1&gt;
&lt;p&gt;Portals能够将子组件渲染到父组件以外的DOM树，他通常用于子组件需要从父组件的容器中脱离出来的场景，有以下场景：&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/29880992&#34;&gt;传送门：React Portal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6892951045685641224&#34;&gt;你真的了解React Portals吗&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-renderprops/ - </description>
        </item>
    
    
    
        <item>
        <title>React-Portals</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-portals/</link>
        <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-portals/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-portals/ -&lt;h1 id=&#34;为什么需要portals&#34;&gt;为什么需要Portals&lt;/h1&gt;
&lt;p&gt;Portals能够将子组件渲染到父组件以外的DOM树，他通常用于子组件需要从父组件的容器中脱离出来的场景，有以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dialog对话框&lt;/li&gt;
&lt;li&gt;Tooltip文字提示&lt;/li&gt;
&lt;li&gt;Popover弹出框&lt;/li&gt;
&lt;li&gt;Loader全局loader&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如某个组件在渲染时，在某种条件下需要显示一个Dialog，最直观的做法，就是直接在JSX中把Dialog画出来，像下面代码的样子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;foo&amp;#34;&lt;/span&gt;&amp;gt;
   &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt;&amp;gt; ... &amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt;&amp;gt;
   { needDialog &lt;span style=&#34;color:#ff79c6&#34;&gt;?&lt;/span&gt; &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;Dialog&lt;/span&gt; /&amp;gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;null&lt;/span&gt; }
&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;问题是，Dialog最终渲染产生的HTML就与上面JSX产生的HTML产生嵌套了，类似下面这样&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;foo&amp;#34;&lt;/span&gt;&amp;gt;
   &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt;&amp;gt; ... &amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt;&amp;gt;
   &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;dialog&amp;#34;&lt;/span&gt;&amp;gt;Dialog Content&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于对话框应该是一个独立的组件，通常应该显示在屏幕的最中间，现在Dialog被包在其它组件中，要用CSS的position属性控制Dialog位置，就要从Dialog往上一直到body都没有其它position是relative的元素干扰。还有一点，Dialog的样式，因为包含在其它元素中，各种样式纠缠，CSS样式太容易搞成一坨浆糊了。&lt;/p&gt;
&lt;p&gt;我们既希望在组件的JSX中选择使用Dialog，把Dialog用的像普通组件一样，但是又希望Dialog内容显示在另一个地方，就需要Portals上场了。&lt;/p&gt;
&lt;p&gt;Portals就是建立一个“传送门”，让Dialog这样的组件在表示层和其它组件没有任何差异，但是渲染的东西却像经过传送门一样出现在另一个地方&lt;/p&gt;
&lt;p&gt;当我们需要在正常的DOM结构之外呈现子组件时，React Portals非常有用，而不需要通过React组件树层次结构破坏事件传播的默认行为，这在渲染例如弹窗、提示时非常有用&lt;/p&gt;
&lt;h1 id=&#34;react-v16的portals支持&#34;&gt;React v16的Portals支持&lt;/h1&gt;
&lt;p&gt;在某个组件中需要使用modal弹框，大多数情况下可以使用fixed定位让这个弹框全局展示，但是特殊情况下，这个modal弹框可能会显示不正常。这个时候如果使用了portals的方式，使modal的dom结构脱离父组件的容器，就可以规避这种问题&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 定义弹框组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; Modal &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; ({message, isOpen, onClose, children}) &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#ff79c6&#34;&gt;!&lt;/span&gt;isOpen) &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;null&lt;/span&gt;
  &lt;span style=&#34;color:#6272a4&#34;&gt;// 创建portals并挂载到body中  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; ReactDOM.createPortal(
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div className&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;modal&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;span&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;{message}&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/span&amp;gt;
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;{onClose}&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;Close&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/button&amp;gt;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
  , &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.body)
}
&lt;span style=&#34;color:#6272a4&#34;&gt;// 弹框使用
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; Component() {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; [open, setOpen] &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; useState(&lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;)
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div className&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;component&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;{() &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; setOpen(&lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;)}&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;/button&amp;gt;
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;Modal
        message&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Hello World!&amp;#34;&lt;/span&gt;
        isOpen&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;{open}
        onClose&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;{() &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; setOpen(&lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;)}
      &lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码能够保证，无论子组件嵌套多深，这个modal能够和root同一级。使用浏览器检查dom结构，就可以看到如下结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/React-Portals/React-Portals.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;portals的事件冒泡&#34;&gt;Portals的事件冒泡&lt;/h1&gt;
&lt;p&gt;v16之前的React Portals实现方法，有一个小小的缺陷，就是Portals是单向的，内容通过Portals传到另一个出口，在那个出口DOM上发生的事件不会冒泡传送回Portals的父组件的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;onClick&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;{onDialogClick}&lt;/span&gt;&amp;gt;   
   &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;Dialog&lt;/span&gt;&amp;gt;
     What ever shit
   &amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;Dialog&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在Dialog画出的内容上点击，onClick是不会被触发的。&lt;/p&gt;
&lt;p&gt;在v16中，通过Portals渲染出去的DOM，事件是会从传送门的入口端冒出来的，上面的onDialogClick也就会被调用到了&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/29880992&#34;&gt;传送门：React Portal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6892951045685641224&#34;&gt;你真的了解React Portals吗&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-portals/ - </description>
        </item>
    
    
    
        <item>
        <title>Html-meta标签</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/html-meta%E6%A0%87%E7%AD%BE/</link>
        <pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/html-meta%E6%A0%87%E7%AD%BE/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/html-meta%E6%A0%87%E7%AD%BE/ -&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;元数据(metadata)是关于数据的信息&lt;/p&gt;
&lt;p&gt;标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。&lt;/p&gt;
&lt;p&gt;典型的情况是，meta元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。&lt;/p&gt;
&lt;p&gt;标签始终位于head元素中。&lt;/p&gt;
&lt;p&gt;元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或者其他web服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;属性&#34;&gt;属性&lt;/h1&gt;
&lt;h2 id=&#34;必需属性&#34;&gt;必需属性&lt;/h2&gt;
&lt;p&gt;meta的必须属性是content，并不是说meta标签里一定要有content，而是当有http-equiv或name属性的时候，一定要有content属性对其进行说明。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;keywords&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;HTML,ASP,PHP,SQL&amp;#34;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;可选属性&#34;&gt;可选属性&lt;/h2&gt;
&lt;h3 id=&#34;http-equiv&#34;&gt;http-equiv&lt;/h3&gt;
&lt;p&gt;添加http头部内容，对一些自定义的，或者需要额外添加的http头部内容，需要发送到浏览器中，我们就可以使用这个属性。&lt;/p&gt;
&lt;p&gt;例如我们不想使用js来重定向，用http头部内容控制，就可以这样控制&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;http-equiv&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Refresh&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;5;url=http://www.baidu.com&amp;#34;&lt;/span&gt; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在页面head中加入这个后，5秒钟后就会跳转到指定的页面&lt;/p&gt;
&lt;h3 id=&#34;name&#34;&gt;name&lt;/h3&gt;
&lt;p&gt;供浏览器进行解析，对于一些浏览器兼容性问题，name是最常用的，当然有个前提就是浏览器能够解析你写进去的name属性才可以&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;renderer&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;webkit&amp;#34;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个meta标签的意思就是告诉浏览器，用webkit内核进行解析，前提是浏览器有webkit内核才可以。当然看到这个你可能会有疑问，这个renderer是从哪里冒出来的？这个就是在对应的浏览器的开发文档里就会有表明的，例如这个renderer是在360浏览器里说明的。&lt;a href=&#34;http://se.360.cn/v6/help/meta.html&#34;&gt;360浏览器内核控制Meta标签说明文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;meta标签总结&#34;&gt;meta标签总结&lt;/h1&gt;
&lt;h2 id=&#34;charset&#34;&gt;charset&lt;/h2&gt;
&lt;p&gt;声明文档使用的字符编码，解决乱码问题主要用的就是它，值得一提的是，这个charset一定要写第一行，不然可能会产生乱码了。&lt;/p&gt;
&lt;p&gt;chartset有两种写法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;utf-8&amp;#34;&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;http-equiv&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Content-Type&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;text/html; charset=utf-8&amp;#34;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;seo-优化部分&#34;&gt;SEO 优化部分&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&amp;lt;!-- 页面标题&amp;lt;title&amp;gt;标签(head 头部必须) --&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;title&lt;/span&gt;&amp;gt;your title&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;title&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#6272a4&#34;&gt;&amp;lt;!-- 页面关键词 keywords --&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;keywords&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;your keywords&amp;#34;&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#6272a4&#34;&gt;&amp;lt;!-- 页面描述内容 description --&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;your description&amp;#34;&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#6272a4&#34;&gt;&amp;lt;!-- 定义网页作者 author --&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;author&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;author,email address&amp;#34;&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#6272a4&#34;&gt;&amp;lt;!-- 定义网页搜索引擎索引方式，robotterms 是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。 --&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;robots&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;index,follow&amp;#34;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;viewport&#34;&gt;viewport&lt;/h2&gt;
&lt;p&gt;主要影响移动端布局的&lt;/p&gt;
&lt;p&gt;之前用h5开发移动项目遇到过字体被缩放的特别小的问题，后来新增了viewport属性解决了，具体如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;viewport&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;width=device-width, user-scalable=no&amp;#34;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;content参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;width viewport 宽度(数值/device-width)&lt;/li&gt;
&lt;li&gt;height viewport 高度(数值/device-height)&lt;/li&gt;
&lt;li&gt;initial-scale 初始缩放比例&lt;/li&gt;
&lt;li&gt;maximum-scale 最大缩放比例&lt;/li&gt;
&lt;li&gt;minimum-scale 最小缩放比例&lt;/li&gt;
&lt;li&gt;user-scalable 是否允许用户缩放(yes/no)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;各浏览器平台&#34;&gt;各浏览器平台&lt;/h2&gt;
&lt;p&gt;一些常用的浏览器meta标签设置参考下方链接&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/yc123h/article/details/51356143&#34;&gt;meta标签的作用及整理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/argenbarbie/p/8026595.html&#34;&gt;chrome手机模拟器显示尺寸不正确&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/html-meta%E6%A0%87%E7%AD%BE/ - </description>
        </item>
    
    
    
        <item>
        <title>React-高阶组件</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</link>
        <pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/ -&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;一个高阶组件只是一个包装了另外一个React组件的React组件&lt;/p&gt;
&lt;h1 id=&#34;基础高阶组件&#34;&gt;基础高阶组件&lt;/h1&gt;
&lt;h2 id=&#34;装饰器模式&#34;&gt;装饰器模式&lt;/h2&gt;
&lt;p&gt;高阶组件可以看做是装饰器模式(Decorator Pattern)在React的实现。即允许向一个现有的对象添加新的功能，同时又不改变其结构，属于包装模式(Wrapper Pattern)的一种&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 定义高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; withHeader &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; (WrappedComponent) &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
    render() {
      &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div className&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;demo-header&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;高阶组件&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;WrappedComponent {...&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props}&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
      )
    }
  }

&lt;span style=&#34;color:#6272a4&#34;&gt;// 调用高阶组件  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;@withHeader&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
  render() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;普通组件&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;组件命名&#34;&gt;组件命名&lt;/h2&gt;
&lt;p&gt;当通过高阶组件来包装一个组件时，你会丢失原先 WrappedComponent 的名字，可能会给开发和 debug 造成影响&lt;/p&gt;
&lt;p&gt;我们改写一下上述的高阶组件代码，增加了getDisplayName函数以及静态属性displayName，此时再去观察DOM Tree&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 获取组件名称
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; getDisplayName(component) {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; component.displayName &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; component.name &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;Component&amp;#39;&lt;/span&gt;
}

&lt;span style=&#34;color:#6272a4&#34;&gt;// 定义高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; withHeader &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; WrappedComponent &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 设置高阶组件别名
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;static&lt;/span&gt; displayName &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;`HOC(&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;${&lt;/span&gt;getDisplayName(WrappedComponent)&lt;span style=&#34;color:#f1fa8c&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;)`&lt;/span&gt;
    render() {
      &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div className&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;demo-header&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;我是标题&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;WrappedComponent {...&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props}&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
      )
    }
  }

&lt;span style=&#34;color:#6272a4&#34;&gt;// 调用高阶组件  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;@withHeader&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
  render() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;我是普通组件&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之前高阶组件仅显示HOC，命名后如下显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/React-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%91%BD%E5%90%8D.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;组件传参&#34;&gt;组件传参&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;柯里化 Curry&lt;/p&gt;
&lt;p&gt;概念：只传递函数的一部分参数来调用它，让它返回一个函数去处理剩下的参数&lt;/p&gt;
&lt;p&gt;函数签名：fun(params)(otherParams)&lt;/p&gt;
&lt;p&gt;应用：在React里，通过柯里化，我们可以通过传入不同的参数来得到不同的高阶组件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 定义高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; withHeader &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; title &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; WrappedComponent &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
    render() {
      &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
          {&lt;span style=&#34;color:#6272a4&#34;&gt;/* 获取参数并使用 */&lt;/span&gt;}
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div className&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;demo-header&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;{title}&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;WrappedComponent {...&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props}&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
      )
    }
  }
  
&lt;span style=&#34;color:#6272a4&#34;&gt;// 调用高阶组件,在括号内定义参数  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;@withHeader&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;我是标题&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
  render() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;普通组件&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;属性代理&#34;&gt;属性代理&lt;/h1&gt;
&lt;h2 id=&#34;更改-props&#34;&gt;更改 props&lt;/h2&gt;
&lt;p&gt;在修改或删除重要 props 的时候要小心，应该给高阶组件的 props 指定命名空间（namespace），以防破坏从外传递给 WrappedComponent 的 props&lt;/p&gt;
&lt;p&gt;下面的例子中定义了一个新的newProps传给组件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 定义高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; withHeader &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; WrappedComponent &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 定义点击事件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    handleClick() {
      console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;)
    }
    render() {
      &lt;span style=&#34;color:#6272a4&#34;&gt;// 定义变量  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; newProps &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
        user&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;王大木&amp;#39;&lt;/span&gt;
      }        
      &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div className&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;demo-header&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;高阶组件&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
          {&lt;span style=&#34;color:#6272a4&#34;&gt;/* 通过props传递变量和点击事件 */&lt;/span&gt;}
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;WrappedComponent {...&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props} {...newProps} handleClick&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.handleClick}&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
      )
    }
  }

&lt;span style=&#34;color:#6272a4&#34;&gt;// 调用高阶组件  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;@withHeader&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
  render() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;普通组件&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
        {&lt;span style=&#34;color:#6272a4&#34;&gt;/* 读取变量 */&lt;/span&gt;}
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;我是newProps：{&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props.user}&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
	    {&lt;span style=&#34;color:#6272a4&#34;&gt;/* 调用点击事件 */&lt;/span&gt;}	
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props.handleClick}&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;点击&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/button&amp;gt;
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;通过-refs-获取组件实例&#34;&gt;通过 refs 获取组件实例&lt;/h2&gt;
&lt;p&gt;当我们包装Usual的时候，想获取到它的实例怎么办，可以通过引用(ref),在Usual组件挂载的时候，会执行ref的回调函数，在HOC中取到组件的实例。通过打印，可以看到它的props， state，都是可以取到的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 定义高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; withHeader &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; WrappedComponent &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
   &lt;span style=&#34;color:#6272a4&#34;&gt;// 装载完成，读取组件并打印
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;   componentDidMount() {
      console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.instanceComponent, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;instanceComponent&amp;#39;&lt;/span&gt;)
    }
    render() {
      &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div className&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;demo-header&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;高阶组件&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
          &lt;span style=&#34;color:#6272a4&#34;&gt;// 引用ref,在组件挂载的时候，会执行ref的回调函数，在HOC中取到组件的实例
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;WrappedComponent {...&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props} ref&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;{instanceComponent &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.instanceComponent &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; instanceComponent}&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
      )
    }
  }

&lt;span style=&#34;color:#6272a4&#34;&gt;// 调用高阶组件  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;@withHeader&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;constructor&lt;/span&gt;(props) {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;super&lt;/span&gt;(props)
      &lt;span style=&#34;color:#6272a4&#34;&gt;// 定义state
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	  &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.state &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
		test&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;普通组件state&amp;#39;&lt;/span&gt;
	}
  }
  render() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;普通组件&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;抽象-state&#34;&gt;抽象 state&lt;/h2&gt;
&lt;p&gt;通过 { props, 回调函数 } 传递给wrappedComponent组件，通过回调函数获取state。用的比较多的就是react处理表单的时候。&lt;/p&gt;
&lt;p&gt;通常react在处理表单的时候，一般使用的是受控组件，即把input都做成受控的，改变value的时候，用onChange事件同步到state中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 定义高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; withHeader &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; WrappedComponent &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;constructor&lt;/span&gt;() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;super&lt;/span&gt;()
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 定义state 
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.state &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
      fields&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; {},
    }
  }
  &lt;span style=&#34;color:#6272a4&#34;&gt;// 通过fieldName绑定控件，触发调用onChange  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  getField &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; fieldName &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; {
      onChange: &lt;span style=&#34;color:#8be9fd&#34;&gt;this.onChange&lt;/span&gt;(fieldName),
    }
  }
  &lt;span style=&#34;color:#6272a4&#34;&gt;// 文本框onChange事件  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  onChange &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; key &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; e &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; {
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;key = &amp;#39;&lt;/span&gt;,key)
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;e = &amp;#39;&lt;/span&gt;,e)      
    &lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; { fields } &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.state
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 将组件视图变化绑定给高阶组件的state
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    fields[key] &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; e.target.value
    &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.setState({
      fields,
    })
  }
  &lt;span style=&#34;color:#6272a4&#34;&gt;// 提交点击事件  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  handleSubmit &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; () &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; {
    console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.state.fields)
  }

  render() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; props &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
      ...&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props,
      handleSubmit: &lt;span style=&#34;color:#8be9fd&#34;&gt;this.handleSubmit&lt;/span&gt;,&lt;span style=&#34;color:#6272a4&#34;&gt;// 提交点击事件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;      getField: &lt;span style=&#34;color:#8be9fd&#34;&gt;this.getField&lt;/span&gt;,&lt;span style=&#34;color:#6272a4&#34;&gt;// 文本框值
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    }
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;WrappedComponent {...props}&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
	)
  }
}

&lt;span style=&#34;color:#6272a4&#34;&gt;// 调用高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;@withHeader&lt;/span&gt;
 &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; Login &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
  render() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;label id&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;账户&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/label&amp;gt;
          {&lt;span style=&#34;color:#6272a4&#34;&gt;/* 绑定文本框 */&lt;/span&gt;}			
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;input name&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt; {...&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props.getField(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;username&amp;#39;&lt;/span&gt;)}&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;label id&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;密码&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/label&amp;gt;
		 {&lt;span style=&#34;color:#6272a4&#34;&gt;/* 绑定文本框 */&lt;/span&gt;}			
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;input name&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; {...&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props.getField(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;password&amp;#39;&lt;/span&gt;)}&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
		{&lt;span style=&#34;color:#6272a4&#34;&gt;/* 调用点击事件 */&lt;/span&gt;}
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div onClick&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props.handleSubmit}&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;提交&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里把state，onChange等方法都放到HOC里，其实是遵从的react组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到Container。比如说我们在HOC获取到用户名密码之后，再去做其他操作，就方便多了，而state，处理函数放到Form组件里，只会让Form更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了&lt;/p&gt;
&lt;h2 id=&#34;包装其它-elements&#34;&gt;包装其它 elements&lt;/h2&gt;
&lt;p&gt;出于操作样式、布局或其它目的，你可以将 WrappedComponent 与其它组件包装在一起&lt;/p&gt;
&lt;p&gt;上面的装饰器模式例子就是将高阶组件与组件包装在了一起&lt;/p&gt;
&lt;h1 id=&#34;反向继承&#34;&gt;反向继承&lt;/h1&gt;
&lt;p&gt;返回的高阶组件类继承了 WrappedComponent。这被叫做反向继承是因为 WrappedComponent 被动地被高阶组件继承，而不是 WrappedComponent 去继承 高阶组件。通过这种方式他们之间的关系倒转了。&lt;/p&gt;
&lt;p&gt;反向继承允许高阶组件通过 &lt;strong&gt;this&lt;/strong&gt; 关键词获取 WrappedComponent，意味着它可以获取到 state，props，组件生命周期（component lifecycle）钩子，以及渲染方法（render）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 定义高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; iiHoc &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; WrappedComponent &lt;span style=&#34;color:#ff79c6&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; WrappedComponent {
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 这里重写了组件的生命周期
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// 如果高阶组件和组件同时定义了相同的生命周期，高阶组件中的会覆盖掉组件中的
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    componentDidMount(){
      console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;hoc didmount&amp;#39;&lt;/span&gt;)
    }
    render() {
      &lt;span style=&#34;color:#6272a4&#34;&gt;// 在高阶组件中读取组件的state
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;      console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;state = &amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.state)
      &lt;span style=&#34;color:#6272a4&#34;&gt;// 继续渲染WrappedComponent组件  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;super&lt;/span&gt;.render()
    }
}

&lt;span style=&#34;color:#6272a4&#34;&gt;// 调用高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;@iiHoc&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; Usual &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;constructor&lt;/span&gt;() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;super&lt;/span&gt;()
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 定义state
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.state &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
      usual&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;usual&amp;#39;&lt;/span&gt;,
    }
  }
  &lt;span style=&#34;color:#6272a4&#34;&gt;// 定义组件的生命周期
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#6272a4&#34;&gt;// 如果高阶组件和组件同时定义了相同的生命周期，高阶组件中的会覆盖掉组件中的
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  componentDidMount() {
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;didMount&amp;#39;&lt;/span&gt;)
  }

  render() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;Usual&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;渲染劫持&#34;&gt;渲染劫持&lt;/h2&gt;
&lt;p&gt;渲染指的是 WrappedComponent.render 方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 定义高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; iiHOC(WrappedComponent) {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; WrappedComponent {
    render() {
      &lt;span style=&#34;color:#6272a4&#34;&gt;// 如果 this.props.loggedIn 是 true，这个高阶组件会原封不动地渲染 WrappedComponent  
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props.loggedIn) {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;super&lt;/span&gt;.render()
      &lt;span style=&#34;color:#6272a4&#34;&gt;// 如果不是 true 则渲染如下内容    
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;      } &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;渲染&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
      }
    }
  }
}

&lt;span style=&#34;color:#6272a4&#34;&gt;// 调用高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;@iiHOC&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; Usual &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
  render() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;Usual&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注意：你不能通过 Props Proxy 来做渲染劫持&lt;/p&gt;
&lt;p&gt;即使你可以通过 WrappedComponent.prototype.render 获取它的 render 方法，你需要自己手动模拟整个实例以及生命周期方法，而不是依靠 React，这是不值当的，应该使用反向继承来做到渲染劫持&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;操作组件state&#34;&gt;操作组件state&lt;/h2&gt;
&lt;p&gt;高阶组件可以 『读取、修改、删除』WrappedComponent 实例的 state，如果需要也可以添加新的 state。&lt;/p&gt;
&lt;p&gt;需要记住的是，你在弄乱 WrappedComponent 的 state，可能会导致破坏一些东西。通常不建议使用高阶组件来读取或添加组件 state，添加 state 需要使用命名空间来防止与 WrappedComponent 的 state 冲突&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 定义高阶组件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; IIHOCDEBUGGER(WrappedComponent) {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; WrappedComponent {
    render() {
      &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
          {&lt;span style=&#34;color:#6272a4&#34;&gt;/* 读取组件props */&lt;/span&gt;}
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;p&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;Props&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/p&amp;gt; &amp;lt;pre&amp;gt;{JSON.stringify(this.props)}&amp;lt;/pre&amp;gt;
          {&lt;span style=&#34;color:#6272a4&#34;&gt;/* 读取组件state */&lt;/span&gt;}
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;p&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;State&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/p&amp;gt;&amp;lt;pre&amp;gt;{JSON.stringify(this.state)}&amp;lt;/pre&amp;gt;
          {&lt;span style=&#34;color:#6272a4&#34;&gt;/* 渲染组件 */&lt;/span&gt;}
          {&lt;span style=&#34;color:#ff79c6&#34;&gt;super&lt;/span&gt;.render()}
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
      )
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;组合多个高阶组件&#34;&gt;组合多个高阶组件&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; HOC1(WrappedComponent) {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; WrappedComponent {
    render() {
      &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div className&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;demo-header&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;高阶组件&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;WrappedComponent {...&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props}&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
      )
    }
  }
}

&lt;span style=&#34;color:#ff79c6&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; HOC2(WrappedComponent) {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; WrappedComponent {
    render() {
      &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div className&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;demo-header&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;高阶组件&lt;span style=&#34;color:#bd93f9&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;WrappedComponent {...&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.props}&lt;span style=&#34;color:#ff79c6&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
      )
    }
  }
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;@HOC1&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;@HOC2&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; Usual &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; React.Component {
  render() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;div&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;普通组件&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用compose可以简化上述过程，也能体现函数式编程的思想&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; enhance &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; compose(withHeader,withLoading);
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;@enhance&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#ff79c6&#34;&gt;extends&lt;/span&gt; Component{
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;组合 Compose
compose可以帮助我们组合任意个高阶函数，例如compose(a,b,c)返回一个新的函数d，函数d依然接受一个函数作为入参，只不过在内部会依次调用c,b,a，从表现层对使用者保持透明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/28138664&#34;&gt;深入浅出React高阶组件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/0aae7d4d9bc1&#34;&gt;深入理解 React 高阶组件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/libin-1/p/7087605.html&#34;&gt;React进阶之高阶组件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://react.docschina.org/docs/higher-order-components.html#caveats&#34;&gt;高阶组件注意事项&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/ - </description>
        </item>
    
    
    
        <item>
        <title>UniApp-App签名</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/uniapp-app%E7%AD%BE%E5%90%8D/</link>
        <pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/uniapp-app%E7%AD%BE%E5%90%8D/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/uniapp-app%E7%AD%BE%E5%90%8D/ -&lt;h1 id=&#34;为什么要有签名&#34;&gt;为什么要有签名&lt;/h1&gt;
&lt;p&gt;开发Android的人这么多，完全有可能把类名，包名命名成同样的名字，这个时候该如何区分？所以，这时候就需要签名来区分了，由于开发商可能通过使用相同的Package Name来混淆替换已经安装的程序，签名可以保证报名相同，但是签名不同的包不被替换。
发布过Android应用的朋友们应该都知道，Android APK的发布是需要签名的。签名机制在Android应用和框架中有着十分重要的作用。例如，Android系统禁止更新安装签名不一致的APK；如果应用需要使用system权限，必须保证APK签名与Framework签名一致&lt;/p&gt;
&lt;h1 id=&#34;注意事项&#34;&gt;注意事项&lt;/h1&gt;
&lt;p&gt;应用程序签名的一些方面可能会影响应用程序的开发过程, 尤其是当你计划发布多个应用时. 通常情况下, 对于所有开发者而言,推荐的策略是:在应用程序的整个生命周期,所有的应用程序使用相同的证书签名.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序升级 – 当发布应用的更新时, 如果想让用户无缝地升级到新版本, 需要继续使用相同的某个或者某一套证书来签名更新包.当系统安装应用的更新时, 它会比较现有版本和新版本的证书. 如果证书吻合, 包括证书数据和顺序都吻合, 那么系统允许更新.如果新版本所做的签名不是匹配的, 那么将需要给应用起一个不同的包名 — 在这种情况下, 用户相当于安装了一个完全的新程序.&lt;/li&gt;
&lt;li&gt;应用程序模块化 – Android允许由相同证书签名的应用程序运行在相同的进程中, 此时系统会将它们作为单个应用程序对待.在这种方式中, 可以按模块化的方式部署应用, 用户可以根据需要独立地更新每一个模块.&lt;/li&gt;
&lt;li&gt;代码/数据 的授权共享 – Android 提供模式匹配的权限控制机制,因此一个应用可以暴露功能给另一个用指定证书签名的应用. 通过用相同证书签名多个应用,以及使用模式匹配的权限检查,应用程序可以以安全的方式共享代码和数据.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u011974987/article/details/52415037&#34;&gt;Android中签名、证书、公钥密钥的概念及使用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/uniapp-app%E7%AD%BE%E5%90%8D/ - </description>
        </item>
    
    
  </channel>
</rss> 