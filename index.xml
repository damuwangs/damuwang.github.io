<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DaMuWang</title>
    <link>https://damuwangs.github.io/</link>
    <description>Recent content on DaMuWang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Sep 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://damuwangs.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>JavaScript-异步解决方案</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
        <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ -&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;Javascript语言的执行环境是&amp;quot;单线程&amp;rdquo;。也就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务。&lt;/p&gt;
&lt;p&gt;这种模式虽然实现起来比较简单，执行环境相对单纯，但是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步和异步&lt;/p&gt;
&lt;h2 id=&#34;同步&#34;&gt;同步&lt;/h2&gt;
&lt;p&gt;所有的任务都处在同一队列中，不可以插队，一个任务执行完接着开始执行下一个，相对于浏览器而言，同步的效率过低&lt;/p&gt;
&lt;h2 id=&#34;异步&#34;&gt;异步&lt;/h2&gt;
&lt;p&gt;将一个任务放入到异步队列中，当这个任务执行完成之后，再从异步队列中提取出来，插队到同步队列中，拿到异步任务的结果，可以提升代码执行的效率，不需要因为一个耗时长的代码而一直等待&lt;/p&gt;
&lt;h1 id=&#34;回调函数&#34;&gt;回调函数&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;ajax(url, () =&amp;gt; {
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 处理逻辑
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假设多个请求存在依赖性，可能就会写出如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;ajax(url, () =&amp;gt; {
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 处理逻辑
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    ajax(url1, () =&amp;gt; {
        &lt;span style=&#34;color:#6272a4&#34;&gt;// 处理逻辑
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;        ajax(url2, () =&amp;gt; {
            &lt;span style=&#34;color:#6272a4&#34;&gt;// 处理逻辑
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;        })
    })
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;优点：解决了同步的问题&lt;/p&gt;
&lt;p&gt;缺点：回调地狱，不能用 try catch 捕获错误，不能 return&lt;/p&gt;
&lt;h1 id=&#34;事件监听&#34;&gt;事件监听&lt;/h1&gt;
&lt;p&gt;这种方式下，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生&lt;/p&gt;
&lt;p&gt;下面是两个函数f1和f2，编程的意图是f2必须等到f1执行完成，才能执行&lt;/p&gt;
&lt;p&gt;f1方法执行完，通过$emit发送一个事件doSomething（vue写法）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;f1(){
	&lt;span style=&#34;color:#6272a4&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// 发送事件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.$emit(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;doSomething&amp;#39;&lt;/span&gt;, {data&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;})
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过$on接收事件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 接收事件
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.$on(doSomething, (res) =&amp;gt; {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (res) {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.f2()
    }    
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以&amp;quot;去耦合&amp;rdquo;，有利于实现模块化&lt;/p&gt;
&lt;p&gt;缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程&lt;/p&gt;
&lt;h1 id=&#34;发布订阅&#34;&gt;发布订阅&lt;/h1&gt;
&lt;p&gt;我们假定，存在一个&amp;quot;信号中心&amp;rdquo;，某个任务执行完成，就向信号中心&amp;quot;发布&amp;rdquo;（publish）一个信号，其他任务可以向信号中心&amp;quot;订阅&amp;rdquo;（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做&amp;quot;发布/订阅模式&amp;rdquo;（publish-subscribe pattern），又称&amp;quot;观察者模式&amp;rdquo;（observer pattern）。&lt;/p&gt;
&lt;p&gt;f2向信号中心jQuery订阅done信号&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;jQuery.subscribe(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;done&amp;#39;&lt;/span&gt;, f2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;jQuery.publish(&amp;lsquo;done&amp;rsquo;)的意思是，f1执行完成后，向信号中心jQuery发布done信号，从而引发f2的执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; f1() {
    setTimeout(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
        &lt;span style=&#34;color:#6272a4&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;        jQuery.publish(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;done&amp;#39;&lt;/span&gt;)
    }, &lt;span style=&#34;color:#bd93f9&#34;&gt;1000&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;f2完成执行后，可以取消订阅（unsubscribe）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;jQuery.unsubscribe(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;done&amp;#39;&lt;/span&gt;, f2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;promise&#34;&gt;Promise&lt;/h1&gt;
&lt;p&gt;Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。 什么时候会用到过一段时间？答案是异步操作，异步是指可能比较长时间才有结果的才做，例如网络请求、读取本地文件等&lt;/p&gt;
&lt;h2 id=&#34;promise的三种状态&#34;&gt;Promise的三种状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Pending&amp;mdash;-进行中&lt;/li&gt;
&lt;li&gt;Fulfilled&amp;mdash;-已成功&lt;/li&gt;
&lt;li&gt;Rejected&amp;mdash;-已失败&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/JavaScript-%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Promise.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，比如说一旦状态变为 resolved 后，就不能再次改变为Fulfilled&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; p &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
  reject(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;reject&amp;#39;&lt;/span&gt;)
  resolve(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;success&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#6272a4&#34;&gt;//无效代码不会执行
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;})
p.then(
  value =&amp;gt; {
    console.log(value)
  },
  reason =&amp;gt; {
    console.log(reason)&lt;span style=&#34;color:#6272a4&#34;&gt;//reject
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
  console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;new Promise&amp;#39;&lt;/span&gt;)
  resolve(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;success&amp;#39;&lt;/span&gt;)
})
console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;new Promise
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;promise的链式调用&#34;&gt;promise的链式调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每次调用返回的都是一个新的Promise实例(这就是then可用链式调用的原因)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果then中返回的是一个结果的话会把这个结果传递下一次then中的成功回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果then中出现异常,会走下一个then的失败回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 then中使用了return，那么 return 的值会被Promise.resolve() 包装(见例1，2)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;then中可以不传递参数，如果不传递会透到下一个then中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;catch 会捕获到没有捕获的异常&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例1&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;.resolve(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
    .then(res =&amp;gt; {
        console.log(res)
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;//包装成 Promise.resolve(2)
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    })
    .&lt;span style=&#34;color:#ff79c6&#34;&gt;catch&lt;/span&gt;(err =&amp;gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;3&lt;/span&gt;)
    .then(res =&amp;gt; console.log(res))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;1
2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例2&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 例2
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;.resolve(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
    .then(x =&amp;gt; x &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
    .then(x =&amp;gt; {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Error&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;My Error&amp;#39;&lt;/span&gt;)
    })
    .&lt;span style=&#34;color:#ff79c6&#34;&gt;catch&lt;/span&gt;(() =&amp;gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
    .then(x =&amp;gt; x &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
    .then(x =&amp;gt; console.log(x))
    .&lt;span style=&#34;color:#ff79c6&#34;&gt;catch&lt;/span&gt;(console.error)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;优点：解决了回调地狱的问题&lt;/p&gt;
&lt;p&gt;缺点：无法取消 Promise ，错误需要通过回调函数来捕获&lt;/p&gt;
&lt;h2 id=&#34;promiseall&#34;&gt;Promise.all&lt;/h2&gt;
&lt;p&gt;Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; p &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;.all([p1, p2, p3]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值&lt;/p&gt;
&lt;p&gt;p的状态由p1、p2、p3决定，分成两种情况&lt;/p&gt;
&lt;p&gt;（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数&lt;/p&gt;
&lt;p&gt;（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; p1 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
  resolve(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;成功了&amp;#39;&lt;/span&gt;)
})

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; p2 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
  resolve(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;success&amp;#39;&lt;/span&gt;)
})

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; p3 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; Promse.reject(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;失败&amp;#39;&lt;/span&gt;)

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;.all([p1, p2]).then((result) =&amp;gt; {
  console.log(result)               &lt;span style=&#34;color:#6272a4&#34;&gt;//[&amp;#39;成功了&amp;#39;, &amp;#39;success&amp;#39;]
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;}).&lt;span style=&#34;color:#ff79c6&#34;&gt;catch&lt;/span&gt;((error) =&amp;gt; {
  console.log(error)
})

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;.all([p1,p3,p2]).then((result) =&amp;gt; {
  console.log(result)
}).&lt;span style=&#34;color:#ff79c6&#34;&gt;catch&lt;/span&gt;((error) =&amp;gt; {
  console.log(error)      &lt;span style=&#34;color:#6272a4&#34;&gt;// 失败了，打出 &amp;#39;失败&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题&lt;/p&gt;
&lt;h2 id=&#34;promiserace&#34;&gt;Promise.race&lt;/h2&gt;
&lt;p&gt;顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; p1 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
  setTimeout(() =&amp;gt; {
    resolve(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;success&amp;#39;&lt;/span&gt;)
  },&lt;span style=&#34;color:#bd93f9&#34;&gt;1000&lt;/span&gt;)
})

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; p2 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
  setTimeout(() =&amp;gt; {
    reject(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;failed&amp;#39;&lt;/span&gt;)
  }, &lt;span style=&#34;color:#bd93f9&#34;&gt;500&lt;/span&gt;)
})

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;.race([p1, p2]).then((result) =&amp;gt; {
  console.log(result)
}).&lt;span style=&#34;color:#ff79c6&#34;&gt;catch&lt;/span&gt;((error) =&amp;gt; {
  console.log(error)  &lt;span style=&#34;color:#6272a4&#34;&gt;// 打开的是 &amp;#39;failed&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;generatoryield&#34;&gt;Generator/yield&lt;/h1&gt;
&lt;p&gt;Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是可以控制函数的执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态&lt;/li&gt;
&lt;li&gt;Generator 函数除了状态机，还是一个遍历器对象生成函数&lt;/li&gt;
&lt;li&gt;可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果&lt;/li&gt;
&lt;li&gt;yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例1&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;foo(x) {
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; y &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; (&lt;span style=&#34;color:#ff79c6&#34;&gt;yield&lt;/span&gt; (x &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;))
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; z &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;yield&lt;/span&gt; (y &lt;span style=&#34;color:#ff79c6&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;3&lt;/span&gt;)
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; (x &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; y &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; z)
}
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; it &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; foo(&lt;span style=&#34;color:#bd93f9&#34;&gt;5&lt;/span&gt;)
console.log(it.next())   &lt;span style=&#34;color:#6272a4&#34;&gt;// =&amp;gt; {value: 6, done: false}
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;console.log(it.next(&lt;span style=&#34;color:#bd93f9&#34;&gt;12&lt;/span&gt;)) &lt;span style=&#34;color:#6272a4&#34;&gt;// =&amp;gt; {value: 8, done: false}
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;console.log(it.next(&lt;span style=&#34;color:#bd93f9&#34;&gt;13&lt;/span&gt;)) &lt;span style=&#34;color:#6272a4&#34;&gt;// =&amp;gt; {value: 42, done: true}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先 Generator 函数调用和普通函数不同，它会返回一个迭代器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当执行第二次 next 时，传入的参数12就会被当作上一个yield表达式的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当执行第三次 next 时，传入的参数13就会被当作上一个yield表达式的返回值，所以 z = 13, x = 5, y = 24，相加等于 42&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例2：有三个本地文件，分别1.txt,2.txt和3.txt，内容都只有一句话，下一个请求依赖上一个请求的结果，想通过Generator函数依次调用三个文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;//1.txt文件
2.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;//2.txt文件
3.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;//3.txt文件
结束
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; fs &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; require(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;fs&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; read(file) {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(resolve, reject) {
    fs.readFile(file, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(err, data) {
      &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (err) reject(err)
      resolve(data)
    })
  })
}
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; r() {
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; r1 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;yield&lt;/span&gt; read(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;./1.txt&amp;#39;&lt;/span&gt;)
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; r2 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;yield&lt;/span&gt; read(r1)
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; r3 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;yield&lt;/span&gt; read(r2)
  console.log(r1)
  console.log(r2)
  console.log(r3)
}
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; it &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; r()
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; { value, done } &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; it.next()
value.then(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(data) { &lt;span style=&#34;color:#6272a4&#34;&gt;// value是个promise
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  console.log(data) &lt;span style=&#34;color:#6272a4&#34;&gt;//data=&amp;gt;2.txt
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; { value, done } &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; it.next(data)
  value.then(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(data) {
    console.log(data) &lt;span style=&#34;color:#6272a4&#34;&gt;//data=&amp;gt;3.txt
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; { value, done } &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; it.next(data)
    value.then(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(data) {
      console.log(data) &lt;span style=&#34;color:#6272a4&#34;&gt;//data=&amp;gt;结束
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    })
  })
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;2.txt
3.txt
结束
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上例中我们看出手动迭代&lt;code&gt;Generator&lt;/code&gt; 函数很麻烦，实现逻辑有点绕，而实际开发一般会配合 &lt;code&gt;co&lt;/code&gt; 库去使用&lt;/p&gt;
&lt;p&gt;co是一个为Node.js和浏览器打造的基于生成器的流程控制工具，借助于Promise，你可以使用更加优雅的方式编写非阻塞代码&lt;/p&gt;
&lt;p&gt;安装co库只需&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;npm install co
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面例子只需两句话就可以轻松实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; r() {
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; r1 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;yield&lt;/span&gt; read(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;./1.txt&amp;#39;&lt;/span&gt;)
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; r2 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;yield&lt;/span&gt; read(r1)
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; r3 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;yield&lt;/span&gt; read(r2)
  console.log(r1)
  console.log(r2)
  console.log(r3)
}
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; co &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; require(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;co&amp;#39;&lt;/span&gt;)
co(r()).then(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(data) {
  console.log(data)
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;2.txt
3.txt
结束
undefined
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例3：我们可以通过 Generator 函数解决回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;fetch() {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;yield&lt;/span&gt; ajax(url, () =&amp;gt; {})
    &lt;span style=&#34;color:#ff79c6&#34;&gt;yield&lt;/span&gt; ajax(url1, () =&amp;gt; {})
    &lt;span style=&#34;color:#ff79c6&#34;&gt;yield&lt;/span&gt; ajax(url2, () =&amp;gt; {})
}
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; it &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; fetch()
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; result1 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; it.next()
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; result2 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; it.next()
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; result3 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; it.next()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;特点：可以控制函数的执行，可以配合 co 函数库使用&lt;/p&gt;
&lt;h1 id=&#34;asyncawait&#34;&gt;Async/await&lt;/h1&gt;
&lt;h2 id=&#34;asyncawait简介&#34;&gt;Async/Await简介&lt;/h2&gt;
&lt;p&gt;使用async/await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;async/await是基于Promise实现的，它不能用于普通的回调函数。&lt;/li&gt;
&lt;li&gt;async/await与Promise一样，是非阻塞的。&lt;/li&gt;
&lt;li&gt;async/await使得异步代码看起来像同步代码，这正是它的魔力所在。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个函数如果加上 async ，那么该函数就会返回一个 Promise&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;async &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; async1() {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;
}
console.log(async1()) &lt;span style=&#34;color:#6272a4&#34;&gt;// -&amp;gt; Promise {&amp;lt;resolved&amp;gt;: &amp;#34;1&amp;#34;}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Generator函数依次调用三个文件那个例子用async/await写法，只需几句话便可实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; fs &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; require(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;fs&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; read(file) {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(resolve, reject) {
    fs.readFile(file, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(err, data) {
      &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (err) reject(err)
      resolve(data)
    })
  })
}
async &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; readResult(params) {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;try&lt;/span&gt; {
    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; p1 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; await read(params, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#6272a4&#34;&gt;//await后面跟的是一个Promise实例
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; p2 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; await read(p1, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;)
    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; p3 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; await read(p2, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;)
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;p1&amp;#39;&lt;/span&gt;, p1)
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;p2&amp;#39;&lt;/span&gt;, p2)
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;p3&amp;#39;&lt;/span&gt;, p3)
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; p3
  } &lt;span style=&#34;color:#ff79c6&#34;&gt;catch&lt;/span&gt; (error) {
    console.log(error)
  }
}
readResult(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;1.txt&amp;#39;&lt;/span&gt;).then( &lt;span style=&#34;color:#6272a4&#34;&gt;// async函数返回的也是个promise
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  data =&amp;gt; {
    console.log(data)
  },
  err =&amp;gt; console.log(err)
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;p1 2.txt
p2 3.txt
p3 结束
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;asyncawait并发请求&#34;&gt;Async/Await并发请求&lt;/h2&gt;
&lt;p&gt;如果请求两个文件，毫无关系，可以通过并发请求&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; fs &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; require(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;fs&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; read(file) {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(resolve, reject) {
    fs.readFile(file, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(err, data) {
      &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (err) reject(err)
      resolve(data)
    })
  })
}
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; readAll() {
  read1()
  read2()&lt;span style=&#34;color:#6272a4&#34;&gt;//这个函数同步执行
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;}
async &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; read1() {
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; r &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; await read(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;1.txt&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;)
  console.log(r)
}
async &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; read2() {
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; r &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; await read(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;2.txt&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;)
  console.log(r)
}
readAll() 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;2.txt 
3.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题&lt;/p&gt;
&lt;p&gt;缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903760280420366#heading-12&#34;&gt;JS 异步编程六种方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/lunahaijiao/article/details/87167417&#34;&gt;JS异步解决方案的发展历程以及优缺点&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ - </description>
        </item>
    
    
    
        <item>
        <title>JavaScript-this指向</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-this%E6%8C%87%E5%90%91/</link>
        <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-this%E6%8C%87%E5%90%91/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-this%E6%8C%87%E5%90%91/ -&lt;h1 id=&#34;this的指向&#34;&gt;this的指向&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看几个简单的例子:&lt;a href=&#34;https://codepen.io/damuwangs/pen/OJgMPxe?editors=0012&#34;&gt;this指向&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;改变this的指向&#34;&gt;改变this的指向&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; name &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;windowsName&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; a &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
    name &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;,

    func1&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
        console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.name)     
    },

    func2&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
        setTimeout(  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
            &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.func1()
        },&lt;span style=&#34;color:#bd93f9&#34;&gt;100&lt;/span&gt;)
    }
}

a.func2()     &lt;span style=&#34;color:#6272a4&#34;&gt;// this.func1 is not a function
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在不使用箭头函数的情况下，是会报错的，因为最后调用setTimeout的对象是 window，但是在 window 中并没有 func1 函数&lt;/p&gt;
&lt;p&gt;我们在改变 this 指向这一节将把这个例子作为 demo 进行改造&lt;/p&gt;
&lt;h2 id=&#34;箭头函数&#34;&gt;箭头函数&lt;/h2&gt;
&lt;p&gt;先看箭头函数和普通函数的重要区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、没有自己的this、super、arguments和new.target绑定&lt;/p&gt;
&lt;p&gt;2、不能使用new来调用&lt;/p&gt;
&lt;p&gt;3、没有原型对象&lt;/p&gt;
&lt;p&gt;4、不可以改变this的绑定&lt;/p&gt;
&lt;p&gt;5、形参名称不能重复&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;箭头函数的 this 始终指向函数定义时的 this，而非执行时，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; name &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;windowsName&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; a &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
    name &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;,

    func1&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
        console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.name)     
    },

    func2&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
        setTimeout( () =&amp;gt; {
            &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.func1()
        },&lt;span style=&#34;color:#bd93f9&#34;&gt;100&lt;/span&gt;)
    }
}

a.func2()     &lt;span style=&#34;color:#6272a4&#34;&gt;// Cherry
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;函数内部使用_this--this&#34;&gt;函数内部使用_this = this&lt;/h2&gt;
&lt;p&gt;先将调用这个函数的对象保存在变量_this中，然后在函数中都使用这个_this，这样_this就不会改变了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; name &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;windowsName&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; a &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
    name &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;,
    
    func1&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
        console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.name)     
    },
    
    func2&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; _this &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;
        setTimeout( &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;() {
            _this.func1()
        },&lt;span style=&#34;color:#bd93f9&#34;&gt;100&lt;/span&gt;)
    }
}

a.func2()       &lt;span style=&#34;color:#6272a4&#34;&gt;// Cherry
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个例子中，在 func2 中，首先设置var _this = this，这里的this 是调用func2的对象 a，为了防止在func2中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将this(指向变量 a)赋值给一个变量 _this，这样，在func2中我们使用this就是指向对象 a 了。&lt;/p&gt;
&lt;h2 id=&#34;使用applycallbind&#34;&gt;使用apply、call、bind&lt;/h2&gt;
&lt;h3 id=&#34;使用-apply&#34;&gt;使用 apply&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; a &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
    name &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;,

    func1&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
        console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.name)
    },

    func2&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
        setTimeout(  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
            &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.func1()
        }.apply(a),&lt;span style=&#34;color:#bd93f9&#34;&gt;100&lt;/span&gt;)
    }
}

a.func2()            &lt;span style=&#34;color:#6272a4&#34;&gt;// Cherry
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用-call&#34;&gt;使用 call&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; a &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
        name &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;,

        func1&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
            console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.name)
        },

        func2&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
            setTimeout(  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
                &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.func1()
            }.call(a),&lt;span style=&#34;color:#bd93f9&#34;&gt;100&lt;/span&gt;)
        }
    }

    a.func2()            &lt;span style=&#34;color:#6272a4&#34;&gt;// Cherry
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用-bind&#34;&gt;使用 bind&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; a &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
        name &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;,

        func1&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
            console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.name)
        },

        func2&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
            setTimeout(  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; () {
                &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.func1()
            }.bind(a)(),&lt;span style=&#34;color:#bd93f9&#34;&gt;100&lt;/span&gt;)
        }
    }

    a.func2()            &lt;span style=&#34;color:#6272a4&#34;&gt;// Cherry
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;applycallbind区别&#34;&gt;apply、call、bind区别&lt;/h2&gt;
&lt;p&gt;其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fapply&#34;&gt;MDN&lt;/a&gt;中定义 apply 如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数&lt;/p&gt;
&lt;p&gt;语法：fun.apply(thisArg, [argsArray])&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;thisArg：在 fun 函数运行时指定的 this 值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call&#34;&gt;MDN&lt;/a&gt;中定义call如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;call()方法使用一个指定的this值和单独给出的一个或多个参数来调用一个函数&lt;/p&gt;
&lt;p&gt;语法：function.call(thisArg, arg1, arg2, &amp;hellip;)&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;thisArg：在function函数运行时使用的this值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;arg1, arg2, &amp;hellip;：指定的参数列表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;我们先来将刚刚的例子使用 bind 试一下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; a &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;{
    name &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;,
    fn &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; (a,b) {
        console.log( a &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; b)
    }
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; b &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; a.fn;
b.bind(a,&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#bd93f9&#34;&gt;2&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们会发现并没有输出，&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&#34;&gt;MDN&lt;/a&gt;中定义bind如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; a &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;{
	name &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;,
	fn &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; (a,b) {
    	console.log( a &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; b)
    }
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; b &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; a.fn
b.bind(a,&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#bd93f9&#34;&gt;2&lt;/span&gt;)()           &lt;span style=&#34;color:#6272a4&#34;&gt;// 3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;js中的函数调用&#34;&gt;JS中的函数调用&lt;/h1&gt;
&lt;h3 id=&#34;普通函数调用模式&#34;&gt;普通函数调用模式&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; name &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;windowsName&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; a() {
	&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; name &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;
	console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.name)          &lt;span style=&#34;color:#6272a4&#34;&gt;// windowsName
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;}
a()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined&lt;/p&gt;
&lt;p&gt;但这是一个全局的函数，很容易产生命名冲突，所以不建议这样使用&lt;/p&gt;
&lt;h3 id=&#34;对象中的函数方法调用模式&#34;&gt;对象中的函数（方法）调用模式&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; name &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;window&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; doSth &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(){
    console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.name)
}
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; student &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
    name&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;若川&amp;#39;&lt;/span&gt;,
    doSth&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; doSth,
    other&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; {
        name&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;other&amp;#39;&lt;/span&gt;,
        doSth&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; doSth,
    }
}
student.doSth() &lt;span style=&#34;color:#6272a4&#34;&gt;// &amp;#39;若川&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;student.other.doSth() &lt;span style=&#34;color:#6272a4&#34;&gt;// &amp;#39;other&amp;#39;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;callapplybind模式&#34;&gt;call、apply、bind模式&lt;/h3&gt;
&lt;p&gt;同上&lt;a href=&#34;http://localhost:1313/posts/%E7%BC%96%E7%A8%8B/javascript-this%E6%8C%87%E5%90%91/#%E4%BD%BF%E7%94%A8applycallbind&#34;&gt;使用apply、call、bind&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;构造函数调用模式&#34;&gt;构造函数调用模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如果函数调用前使用了 new 关键字, 则是调用了构造函数
这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 构造函数:
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; myFunction(arg1, arg2) {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.firstName &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; arg1
    &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.lastName  &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; arg2
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; a &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; myFunction(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Li&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;);
a.lastName  &lt;span style=&#34;color:#6272a4&#34;&gt;// 返回 &amp;#34;Cherry&amp;#34;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就有要说另一个面试经典问题：new 的过程了，(ಥ_ಥ)
这里就简单的来看一下 new 的过程吧：
伪代码表示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; a &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; myFunction(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Li&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;);

&lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; myFunction{
    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; obj &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {};
    obj.__proto__ &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; myFunction.prototype;
    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; result &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; myFunction.call(obj,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Li&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Cherry&amp;#34;&lt;/span&gt;);
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;typeof&lt;/span&gt; result &lt;span style=&#34;color:#ff79c6&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;obj&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;?&lt;/span&gt; result &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; obj;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建一个空对象 obj&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将新创建的空对象的隐式原型指向其构造函数的显示原型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 call 改变 this 的指向&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；&lt;/p&gt;
&lt;p&gt;如果返回值是一个新对象的话那么直接直接返回该对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。&lt;/p&gt;
&lt;h3 id=&#34;原型链中的调用模式&#34;&gt;原型链中的调用模式&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; Student(name){
    &lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.name &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; name
}
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; s1 &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; Student(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;若川&amp;#39;&lt;/span&gt;)
Student.prototype.doSth &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(){
    console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.name)
}
s1.doSth() &lt;span style=&#34;color:#6272a4&#34;&gt;// &amp;#39;若川&amp;#39;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;箭头函数调用模式&#34;&gt;箭头函数调用模式&lt;/h3&gt;
&lt;p&gt;同上&lt;a href=&#34;http://localhost:1313/posts/%E7%BC%96%E7%A8%8B/javascript-this%E6%8C%87%E5%90%91/#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0&#34;&gt;箭头函数&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2018/06/javascript-this.html&#34;&gt;JavaScript 的 this 原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903496253177863&#34;&gt;this、apply、call、bind&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903746984476686#heading-13&#34;&gt;面试官问：JS的this指向&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-this%E6%8C%87%E5%90%91/ - </description>
        </item>
    
    
    
        <item>
        <title>【待补充】乐理</title>
        <link>https://damuwangs.github.io/posts/%E9%9F%B3%E4%B9%90/%E4%B9%90%E7%90%86/</link>
        <pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E9%9F%B3%E4%B9%90/%E4%B9%90%E7%90%86/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E9%9F%B3%E4%B9%90/%E4%B9%90%E7%90%86/ -&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;JavaScript 是一门单线程语言，即同一时间只能执行一个任务，即代码执行是同步并且阻塞的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举例：这就像只有一个窗口的银行，客户需要一个一个排队办理业务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只能同步执行肯定是有问题的，所以 JS 有了一个用来实现异步的函数：&lt;code&gt;setTimeout&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面要讲的 Event Loop 就是为了确保 异步代码 可以在 同步代码 执行后继续执行的。&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/formercoding/p/12906640.html&#34;&gt;JS事件循环（Event Loop）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000019313028&#34;&gt;浅析 JS 中的 EventLoop 事件循环（新手向）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E9%9F%B3%E4%B9%90/%E4%B9%90%E7%90%86/ - </description>
        </item>
    
    
    
        <item>
        <title>【待补充】四川-贡嘎</title>
        <link>https://damuwangs.github.io/posts/%E6%97%85%E8%A1%8C/%E5%9B%9B%E5%B7%9D-%E8%B4%A1%E5%98%8E/</link>
        <pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E6%97%85%E8%A1%8C/%E5%9B%9B%E5%B7%9D-%E8%B4%A1%E5%98%8E/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E6%97%85%E8%A1%8C/%E5%9B%9B%E5%B7%9D-%E8%B4%A1%E5%98%8E/ -&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;JavaScript 是一门单线程语言，即同一时间只能执行一个任务，即代码执行是同步并且阻塞的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举例：这就像只有一个窗口的银行，客户需要一个一个排队办理业务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只能同步执行肯定是有问题的，所以 JS 有了一个用来实现异步的函数：&lt;code&gt;setTimeout&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面要讲的 Event Loop 就是为了确保 异步代码 可以在 同步代码 执行后继续执行的。&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/formercoding/p/12906640.html&#34;&gt;JS事件循环（Event Loop）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000019313028&#34;&gt;浅析 JS 中的 EventLoop 事件循环（新手向）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E6%97%85%E8%A1%8C/%E5%9B%9B%E5%B7%9D-%E8%B4%A1%E5%98%8E/ - </description>
        </item>
    
    
    
        <item>
        <title>【待补充】山东-青岛</title>
        <link>https://damuwangs.github.io/posts/%E6%97%85%E8%A1%8C/%E5%B1%B1%E4%B8%9C-%E9%9D%92%E5%B2%9B/</link>
        <pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E6%97%85%E8%A1%8C/%E5%B1%B1%E4%B8%9C-%E9%9D%92%E5%B2%9B/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E6%97%85%E8%A1%8C/%E5%B1%B1%E4%B8%9C-%E9%9D%92%E5%B2%9B/ -&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;JavaScript 是一门单线程语言，即同一时间只能执行一个任务，即代码执行是同步并且阻塞的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举例：这就像只有一个窗口的银行，客户需要一个一个排队办理业务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只能同步执行肯定是有问题的，所以 JS 有了一个用来实现异步的函数：&lt;code&gt;setTimeout&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面要讲的 Event Loop 就是为了确保 异步代码 可以在 同步代码 执行后继续执行的。&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/formercoding/p/12906640.html&#34;&gt;JS事件循环（Event Loop）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000019313028&#34;&gt;浅析 JS 中的 EventLoop 事件循环（新手向）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E6%97%85%E8%A1%8C/%E5%B1%B1%E4%B8%9C-%E9%9D%92%E5%B2%9B/ - </description>
        </item>
    
    
    
        <item>
        <title>关于热量消耗与营养摄入的思考</title>
        <link>https://damuwangs.github.io/posts/%E5%81%A5%E8%BA%AB/%E8%9B%8B%E7%99%BD%E8%B4%A8%E6%91%84%E5%85%A5%E4%B8%8E%E7%83%AD%E9%87%8F%E7%BC%BA%E5%8F%A3%E8%AE%A1%E7%AE%97/</link>
        <pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E5%81%A5%E8%BA%AB/%E8%9B%8B%E7%99%BD%E8%B4%A8%E6%91%84%E5%85%A5%E4%B8%8E%E7%83%AD%E9%87%8F%E7%BC%BA%E5%8F%A3%E8%AE%A1%E7%AE%97/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E5%81%A5%E8%BA%AB/%E8%9B%8B%E7%99%BD%E8%B4%A8%E6%91%84%E5%85%A5%E4%B8%8E%E7%83%AD%E9%87%8F%E7%BC%BA%E5%8F%A3%E8%AE%A1%E7%AE%97/ -&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;减脂的基本原理其实非常的简单，日常总热量的摄入要小于总热量的消耗，造成热量亏空，为了达到能量收支的平衡，体内储存的脂肪就会氧化消耗来填补缺失的热量，长此以往，体内储存的脂肪就会被消耗得越来越少&lt;/p&gt;
&lt;p&gt;人体一天的能量消耗主要有四个方面：基础代谢、体力活动、食物热效应以及生长发育&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;减肥=摄入热量-消耗热量=吃下食物的热量-（基础代谢热量+运动消耗热量）&lt;/p&gt;
&lt;p&gt;一天最好是有300~500Kcal以上的热量差。但不要一下子超过800Kcal&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;基础代谢（BRM）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;男性基础代谢率=67+13.73×体重(kg)+5×身高(cm)-6.9×年龄&lt;/p&gt;
&lt;p&gt;我目前：身高173、体重72、年龄27，按此公式计算出的基础代谢为1734Kcal&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每日消耗总量（TDEE）=基础代谢 x 活动程度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;活动程度影响的因素比较多，针对不同人群的运动情况也是有所不同的。数值如下：&lt;/p&gt;
&lt;p&gt;久坐族/无运动习惯者：1.2&lt;/p&gt;
&lt;p&gt;轻度运动者/一周一至三天运动：1.375&lt;/p&gt;
&lt;p&gt;中度运动者/一周三至五天运动：1.55（大部分健身爱好者）&lt;/p&gt;
&lt;p&gt;激烈运动者/一周六至七天运动：1.725&lt;/p&gt;
&lt;p&gt;超激烈运动者/体力活的工作/一天训练两次：1.9&lt;/p&gt;
&lt;h2 id=&#34;运动&#34;&gt;运动&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/%E8%9B%8B%E7%99%BD%E8%B4%A8%E6%91%84%E5%85%A5%E4%B8%8E%E7%83%AD%E9%87%8F%E7%BC%BA%E5%8F%A3%E8%AE%A1%E7%AE%97/%E8%BF%90%E5%8A%A8%E7%83%AD%E9%87%8F%E6%B6%88%E8%80%97.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;饮食&#34;&gt;饮食&lt;/h2&gt;
&lt;p&gt;各营养素与热量摄入总量的百分比为：碳水40%，蛋白质30%，脂肪30%&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;我目前身高173cm、体重72kg、年龄27&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每日消耗总量为1734x1.55=2687.7&lt;/p&gt;
&lt;p&gt;因为查询出来的结果各不相同，保守将我的每日总消耗记为2500Kcal&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我的每日总消耗为2500Kcal，那么每天固定要摄入2500Kcal热量的食物。然后靠运动来消耗掉400Kcal&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;健身一小时大约会消耗400Kcal的热量&lt;/p&gt;
&lt;p&gt;那么总消耗2900，摄入2500，这样每天400Kcal的能量缺口就可以达到减脂的目的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么2500Kcal分配到每日的饮食中是怎么样一个概念，在保证营养均衡的前提下，每天需要摄入1000Kcal碳水、750Kcal蛋白质、750Kcal脂肪，对照热量查询工具&lt;/p&gt;
&lt;p&gt;一个鸡蛋：约50g 约6g蛋白质，70Kcal&lt;/p&gt;
&lt;p&gt;一块鸡胸肉：约120g 约30g蛋白质 142Kcal&lt;/p&gt;
&lt;p&gt;一勺蛋白粉：约40g 约30g蛋白质 约162Kcal&lt;/p&gt;
&lt;p&gt;一碗米饭：约300g 约75g碳水 约340Kcal&lt;/p&gt;
&lt;p&gt;一碗面：约500g 约110g碳水 约530Kcal&lt;/p&gt;
&lt;p&gt;一个馒头：约100g 约47g碳水 约220Kcal&lt;/p&gt;
&lt;p&gt;增肌时蛋白质每公斤体重2g 碳水每公斤体重6g 脂肪不单独摄入 分五顿&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;减脂情况下每天&lt;/p&gt;
&lt;p&gt;蛋白质需要大概6个鸡蛋、一块鸡胸肉、一勺蛋白粉&lt;/p&gt;
&lt;p&gt;碳水大概一碗面、一碗米饭&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;增肌情况每天&lt;/p&gt;
&lt;p&gt;蛋白质需要10个鸡蛋、两块鸡胸肉、一勺蛋白粉&lt;/p&gt;
&lt;p&gt;碳水大概两碗面、两碗米饭&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boohee.com/food&#34;&gt;热量查询&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://psychologyandfitness.cn/bmrtdeecalculator/&#34;&gt;基础代谢计算&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.sohu.com/a/380044473_685943&#34;&gt;增肌减脂必知BMR&amp;amp;TDEE计算口诀&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E5%81%A5%E8%BA%AB/%E8%9B%8B%E7%99%BD%E8%B4%A8%E6%91%84%E5%85%A5%E4%B8%8E%E7%83%AD%E9%87%8F%E7%BC%BA%E5%8F%A3%E8%AE%A1%E7%AE%97/ - </description>
        </item>
    
    
    
        <item>
        <title>JavaScript-EventLoop事件循环</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link>
        <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/ -&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;JavaScript 是一门单线程语言，即同一时间只能执行一个任务，即代码执行是同步并且阻塞的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举例：这就像只有一个窗口的银行，客户需要一个一个排队办理业务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只能同步执行肯定是有问题的，所以 JS 有了一个用来实现异步的函数：&lt;code&gt;setTimeout&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Event Loop 就是为了确保 异步代码 可以在 同步代码 执行后继续执行的&lt;/p&gt;
&lt;h2 id=&#34;队列queue&#34;&gt;队列（Queue）&lt;/h2&gt;
&lt;p&gt;队列是一种FIFO(First In, First Out) 的数据结构，它的特点就是先进先出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举例：生活中最常见的例子就是排队，排在队伍最前面的人最先被提供服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;栈stack&#34;&gt;栈（Stack）&lt;/h2&gt;
&lt;p&gt;栈是一种 LIFO（Last In, First Out）的数据结构，特点即后进先出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;样例：大家都吃过桶装薯片吧~薯片在包装的时候只能从顶部放入，而吃的时候也只能从顶部拿出，这就叫后进先出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;调用栈call-stack&#34;&gt;调用栈（Call Stack）&lt;/h2&gt;
&lt;p&gt;调用栈本质上当然还是个栈，关键在于它里面装的东西，是一个个待执行的函数&lt;/p&gt;
&lt;p&gt;Event Loop 会一直检查 Call Stack 中是否有函数需要执行，如果有，就从栈顶依次执行。同时，如果执行的过程中发现其他函数，继续入栈然后执行&lt;/p&gt;
&lt;p&gt;先拿两个函数来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈空&lt;/li&gt;
&lt;li&gt;现在执行到一个函数A，函数A入栈&lt;/li&gt;
&lt;li&gt;函数A 又调用了函数B，函数B入栈&lt;/li&gt;
&lt;li&gt;函数B执行完后出栈&lt;/li&gt;
&lt;li&gt;然后继续执行函数A，执行完后A也出栈&lt;/li&gt;
&lt;li&gt;栈空&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看一段代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; bar &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; () =&amp;gt; console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; baz &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; () =&amp;gt; console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;baz&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; foo &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; () =&amp;gt; {
	console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;)
	bar()
	baz()
}
foo()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码在 调用栈中的运行顺序如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/JavaScript-EventLoop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/%E8%B0%83%E7%94%A8%E6%A0%88.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面我们讨论的其实都是同步代码，代码在运行的时候只用 调用栈 解释就可以了&lt;/p&gt;
&lt;p&gt;那么，假如我们发起了一个网络请求(request)，或者设置了一个定时器延时(setTimeout)，一段时间后的代码（回调函数）肯定不是直接被加到调用栈吧？&lt;/p&gt;
&lt;p&gt;这时就要引出事件表格（Event Table）和事件队列 (Event Queue)了&lt;/p&gt;
&lt;h2 id=&#34;event-table&#34;&gt;Event Table&lt;/h2&gt;
&lt;p&gt;Event Table 可以理解成一张 &lt;code&gt;事件-&amp;gt;回调函数&lt;/code&gt; 对应表&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它就是用来存储 JavaScript 中的异步事件 (request, setTimeout, IO等) 及其对应的回调函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;event-queue&#34;&gt;Event Queue&lt;/h2&gt;
&lt;p&gt;Event Queue 简单理解就是 &lt;code&gt;回调函数 队列&lt;/code&gt;，所以它也叫 Callback Queue&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当 Event Table 中的事件被触发，事件对应的回调函数就会被 push 进这个 Event Queue，然后等待被执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;event-loop&#34;&gt;Event Loop&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/JavaScript-EventLoop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/EventLoop.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始，任务先进入 Call Stack&lt;/li&gt;
&lt;li&gt;同步任务直接在栈中等待被执行，异步任务从 Call Stack 移入到 Event Table 注册&lt;/li&gt;
&lt;li&gt;当对应的事件触发（或延迟到指定时间），Event Table 会将事件回调函数移入 Event Queue 等待&lt;/li&gt;
&lt;li&gt;当 Call Stack 中没有任务，就从 Event Queue 中拿出一个任务放入 Call Stack&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而Event Loop指的就是这一整个圈圈：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它不停检查 Call Stack 中是否有任务（也叫栈帧）需要执行，如果没有，就检查 Event Queue，从中弹出一个任务，放入 Call Stack 中，如此往复循环。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;宏任务与微任务&#34;&gt;宏任务与微任务&lt;/h2&gt;
&lt;p&gt;微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/JavaScript-EventLoop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入Event Queue，然后在执行微任务，将微任务放入Event Queue，这两个Queue不是一个Queue。&lt;/p&gt;
&lt;p&gt;当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的Queue上拿宏任务的回掉函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而宏任务一般是：包括整体代码script，setTimeout，setInterval、setImmediate。&lt;/p&gt;
&lt;p&gt;微任务：原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver 记住就行了&lt;/p&gt;
&lt;h2 id=&#34;settimeout&#34;&gt;setTimeout&lt;/h2&gt;
&lt;p&gt;我们经常这么实现延时3秒执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;setTimeout(() =&amp;gt; {
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;延时3秒&amp;#39;&lt;/span&gt;)
},&lt;span style=&#34;color:#bd93f9&#34;&gt;3000&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;setTimeout(() =&amp;gt; {
    task()
},&lt;span style=&#34;color:#bd93f9&#34;&gt;3000&lt;/span&gt;)
console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;执行console&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;// 执行console
// task()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;去验证一下，结果正确！ 然后我们修改一下前面的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;setTimeout(() =&amp;gt; {
    task()
},&lt;span style=&#34;color:#bd93f9&#34;&gt;3000&lt;/span&gt;)
sleep(&lt;span style=&#34;color:#bd93f9&#34;&gt;10000000&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;乍一看其实差不多，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？&lt;/p&gt;
&lt;p&gt;这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;task()进入Event Table并注册,计时开始&lt;/li&gt;
&lt;li&gt;执行sleep函数，很慢，非常慢，计时仍在继续&lt;/li&gt;
&lt;li&gt;3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着&lt;/li&gt;
&lt;li&gt;sleep终于执行完了，task()终于从Event Queue进入了主线程执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远大于3秒&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//代码1
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;先执行这里&amp;#39;&lt;/span&gt;)
setTimeout(() =&amp;gt; {
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;执行啦&amp;#39;&lt;/span&gt;)
},&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;)
&lt;span style=&#34;color:#6272a4&#34;&gt;//代码2
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;先执行这里&amp;#39;&lt;/span&gt;)
setTimeout(() =&amp;gt; {
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;执行啦&amp;#39;&lt;/span&gt;)
},&lt;span style=&#34;color:#bd93f9&#34;&gt;3000&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码1的输出结果是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;先执行这里
执行啦
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码2的输出结果是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//先执行这里
// ... 3s later
// 执行啦
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒&lt;/p&gt;
&lt;h2 id=&#34;setinterval&#34;&gt;setInterval&lt;/h2&gt;
&lt;p&gt;上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待&lt;/p&gt;
&lt;p&gt;唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了&lt;/p&gt;
&lt;h2 id=&#34;promise与processnexttick&#34;&gt;Promise与process.nextTick&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Promise的定义和功能本文不再赘述，可以学习一下 &lt;a href=&#34;https://link.juejin.cn/?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise&#34;&gt;阮一峰老师的Promise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;而process.nextTick(callback)类似node.js版的&amp;quot;setTimeout&amp;rdquo;，在事件循环的下一次循环中调用 callback 回调函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同类型的任务会进入对应的Event Queue，比如&lt;code&gt;setTimeout&lt;/code&gt;和&lt;code&gt;setInterval&lt;/code&gt;会进入相同的Event Queue&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;setTimeout(()=&amp;gt;{
  console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;setTimeout1&amp;#39;&lt;/span&gt;)
},&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;)
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; p &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;((resolve,reject)=&amp;gt;{
  console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;Promise1&amp;#39;&lt;/span&gt;)
  resolve()
})
p.then(()=&amp;gt;{
  console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;Promise2&amp;#39;&lt;/span&gt;)    
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;Promise1
Promise2
setTimeout1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Promise参数中的Promise1是同步执行的 其次是因为Promise是microtasks，会在同步任务执行完后会去清空microtasks queues， 最后清空完微任务再去宏任务队列取值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;.resolve().then(()=&amp;gt;{
  console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;Promise1&amp;#39;&lt;/span&gt;)  
  setTimeout(()=&amp;gt;{
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;setTimeout2&amp;#39;&lt;/span&gt;)
  },&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;)
})

setTimeout(()=&amp;gt;{
  console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;setTimeout1&amp;#39;&lt;/span&gt;)
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;.resolve().then(()=&amp;gt;{
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;Promise2&amp;#39;&lt;/span&gt;)    
  })
},&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;Promise1
setTimeout1
Promise2
setTimeout2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一开始执行栈的同步任务执行完毕，会去 microtasks queues 找 清空 microtasks queues ，输出Promise1，同时会生成一个异步任务 setTimeout1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去宏任务队列查看此时队列是 setTimeout1 在 setTimeout2 之前，因为setTimeout1执行栈一开始的时候就开始异步执行,所以输出setTimeout1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在执行setTimeout1时会生成Promise2的一个 microtasks ，放入 microtasks queues 中，接着又是一个循环，去清空 microtasks queues ，输出Promise2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清空完 microtasks queues ，就又会去宏任务队列取一个，这回取的是setTimeout2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后我们来分析一段较复杂的代码，掌握js的执行机制：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;);

setTimeout(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;() {
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;);
    process.nextTick(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;() {
        console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;);
    })
    &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(resolve) {
        console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;);
        resolve();
    }).then(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;() {
        console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;5&amp;#39;&lt;/span&gt;)
    })
})
process.nextTick(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;() {
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;6&amp;#39;&lt;/span&gt;);
})
&lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(resolve) {
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;);
    resolve();
}).then(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;() {
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;8&amp;#39;&lt;/span&gt;)
})

setTimeout(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;() {
    console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;);
    process.nextTick(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;() {
        console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;10&amp;#39;&lt;/span&gt;);
    })
    &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(resolve) {
        console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;11&amp;#39;&lt;/span&gt;);
        resolve();
    }).then(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;() {
        console.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;12&amp;#39;&lt;/span&gt;)
    })
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一轮事件循环流程分析如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整体script作为第一个宏任务进入主线程，遇到console.log，输出1&lt;/li&gt;
&lt;li&gt;遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1&lt;/li&gt;
&lt;li&gt;遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1&lt;/li&gt;
&lt;li&gt;遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1&lt;/li&gt;
&lt;li&gt;又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏任务Event Queue&lt;/th&gt;
&lt;th&gt;微任务Event Queue&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;setTimeout1&lt;/td&gt;
&lt;td&gt;process1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setTimeout2&lt;/td&gt;
&lt;td&gt;then1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们发现了process1和then1两个微任务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行process1,输出6&lt;/li&gt;
&lt;li&gt;执行then1，输出8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2&lt;/li&gt;
&lt;li&gt;new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏任务Event Queue&lt;/th&gt;
&lt;th&gt;微任务Event Queue&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;setTimeout2&lt;/td&gt;
&lt;td&gt;process3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;then3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。&lt;/p&gt;
&lt;p&gt;输出10&lt;/p&gt;
&lt;p&gt;输出12&lt;/p&gt;
&lt;p&gt;第三轮事件循环结束，第三轮输出9，11，10，12&lt;/p&gt;
&lt;p&gt;整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12&lt;/p&gt;
&lt;p&gt;node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/formercoding/p/12906640.html&#34;&gt;JS事件循环（Event Loop）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000019313028&#34;&gt;浅析 JS 中的 EventLoop 事件循环（新手向）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903638238756878&#34;&gt;JS事件循环机制（event loop）之宏任务/微任务&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/ - </description>
        </item>
    
    
    
        <item>
        <title>JavaScript-事件冒泡、事件捕获和事件委托</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</link>
        <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/ -&lt;h1 id=&#34;事件流&#34;&gt;事件流&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/JavaScript-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/%E4%BA%8B%E4%BB%B6%E6%B5%81.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;outer&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;inner&amp;#34;&lt;/span&gt;&amp;gt;Click me!&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;p&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？&lt;/p&gt;
&lt;p&gt;为了解决这个问题微软和网景提出了两种几乎完全相反的概念&lt;/p&gt;
&lt;h1 id=&#34;事件冒泡&#34;&gt;事件冒泡&lt;/h1&gt;
&lt;h5 id=&#34;概念&#34;&gt;概念&lt;/h5&gt;
&lt;p&gt;微软提出了名为&lt;strong&gt;事件冒泡&lt;/strong&gt;(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象&lt;/p&gt;
&lt;h5 id=&#34;样例事件冒泡httpscodepeniodamuwangspenwvebzggeditors1000&#34;&gt;样例：&lt;a href=&#34;https://codepen.io/damuwangs/pen/wveBZgG?editors=1000&#34;&gt;事件冒泡&lt;/a&gt;&lt;/h5&gt;
&lt;h1 id=&#34;阻止事件冒泡&#34;&gt;阻止事件冒泡&lt;/h1&gt;
&lt;p&gt;事件的对象有一个stopPropagation()方法可以阻止事件冒泡，我们只需要把上个例子中button的事件处理程序修改如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;button&amp;#34;&lt;/span&gt;).addEventListener(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(event){
	alert(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;button&amp;#34;&lt;/span&gt;)
	event.stopPropagation()
},&lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;事件捕获&#34;&gt;事件捕获&lt;/h1&gt;
&lt;h5 id=&#34;概念-1&#34;&gt;概念&lt;/h5&gt;
&lt;p&gt;网景提出另一种事件流名为&lt;strong&gt;事件捕获&lt;/strong&gt;(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素&lt;/p&gt;
&lt;h5 id=&#34;样例事件捕获httpscodepeniodamuwangspenojgpgxn&#34;&gt;样例：&lt;a href=&#34;https://codepen.io/damuwangs/pen/OJgPGxN&#34;&gt;事件捕获&lt;/a&gt;&lt;/h5&gt;
&lt;h1 id=&#34;阻止事件捕获&#34;&gt;阻止事件捕获&lt;/h1&gt;
&lt;p&gt;但是我们可以使用DOM3级新增事件stopImmediatePropagation()方法来阻止事件捕获，另外此方法还可以阻止事件冒泡。应用如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;second&amp;#34;&lt;/span&gt;).addEventListener(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(event){
    alert(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;second&amp;#34;&lt;/span&gt;)
    event.stopImmediatePropagation()
},&lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么 stopImmediatePropagation() 和 stopPropagation()的区别在哪儿呢？&lt;/p&gt;
&lt;p&gt;后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生&lt;/p&gt;
&lt;h1 id=&#34;事件委托&#34;&gt;事件委托&lt;/h1&gt;
&lt;p&gt;在实际的开发当中，利用事件流的特性，我们可以使用一种叫做事件代理的方法&lt;/p&gt;
&lt;h5 id=&#34;样例&#34;&gt;样例&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;ul&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;color_list&amp;#34;&lt;/span&gt;&amp;gt;        
    &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;red&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;        
    &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;orange&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;        
    &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;yellow&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;        
    &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;green&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;        
    &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;blue&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;        
    &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;purple&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;&amp;gt;    
&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;ul&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;box&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;.&lt;span style=&#34;color:#50fa7b&#34;&gt;color_list&lt;/span&gt;{            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;display&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;flex&lt;/span&gt;;            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;display&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;-webkit-&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;flex&lt;/span&gt;;        
}        
.&lt;span style=&#34;color:#50fa7b&#34;&gt;color_list&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;li&lt;/span&gt;{            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;width&lt;/span&gt;: &lt;span style=&#34;color:#bd93f9&#34;&gt;100&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;px&lt;/span&gt;;            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;height&lt;/span&gt;: &lt;span style=&#34;color:#bd93f9&#34;&gt;100&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;px&lt;/span&gt;;            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;list-style&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;none&lt;/span&gt;;            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;text-align&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;center&lt;/span&gt;;            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;line-height&lt;/span&gt;: &lt;span style=&#34;color:#bd93f9&#34;&gt;100&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;px&lt;/span&gt;;        
}
&lt;span style=&#34;color:#ff79c6&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;每个li加上对应的颜色&lt;/span&gt;，&lt;span style=&#34;color:#ff79c6&#34;&gt;此处省略&lt;/span&gt;
.&lt;span style=&#34;color:#50fa7b&#34;&gt;box&lt;/span&gt;{            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;width&lt;/span&gt;: &lt;span style=&#34;color:#bd93f9&#34;&gt;600&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;px&lt;/span&gt;;            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;height&lt;/span&gt;: &lt;span style=&#34;color:#bd93f9&#34;&gt;150&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;px&lt;/span&gt;;            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;background-color&lt;/span&gt;: &lt;span style=&#34;color:#bd93f9&#34;&gt;#cccccc&lt;/span&gt;;            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;line-height&lt;/span&gt;: &lt;span style=&#34;color:#bd93f9&#34;&gt;150&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;px&lt;/span&gt;;            
    &lt;span style=&#34;color:#ff79c6&#34;&gt;text-align&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;center&lt;/span&gt;;        
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://damuwangs.github.io/img/JavaScript-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们想要在点击每个 li 标签时，输出li当中的颜色（innerHTML） 。常规做法是遍历每个 li ,然后在每个 li 上绑定一个点击事件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; color_list&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.querySelector(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;.color_list&amp;#34;&lt;/span&gt;)     
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; colors&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;color_list.getElementsByTagName(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;li&amp;#34;&lt;/span&gt;)         
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; box&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.querySelector(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;.box&amp;#34;&lt;/span&gt;)     
&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;let&lt;/span&gt; n&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;;n&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;colors.length;n&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;){                
    colors[n].addEventListener(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(){                    
        console.log(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.innerHTML)                    
        box.innerHTML&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;该颜色为 &amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;.innerHTML         
    })            
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种做法在 li 较少的时候可以使用，但如果有一万个li，那就会导致性能降低（少了遍历所有 li 节点的操作，性能上肯定更加优化）。这时就需要事件代理出场了，利用事件流的特性，我们只绑定一个事件处理函数也可以完成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; colorChange(e){                   
    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt;(e.target.nodeName.toLowerCase()&lt;span style=&#34;color:#ff79c6&#34;&gt;===&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;li&amp;#34;&lt;/span&gt;){                    
        box.innerHTML&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;该颜色为 &amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;e.target.innerHTML          
    }                            
}            
color_list.addEventListener(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;,colorChange,&lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于事件冒泡机制，点击了li后会冒泡到ul，此时就会触发绑定在ul上的点击事件，再利用target找到事件实际发生的元素，就可以达到预期的效果&lt;/p&gt;
&lt;p&gt;使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法。假如上述列表元素当中添加了其他的元素节点（如：a、span等），我们不必再一次循环给每一个元素绑定事件，直接修改事件代理的事件处理函数即可&lt;/p&gt;
&lt;p&gt;（1）toLowerCase()方法用于把字符串转换为小写。语法：stringObject.toLowerCase()&lt;/p&gt;
&lt;p&gt;返回值：一个新的字符串，在其中 stringObject 的所有大写字符全部被转换为了小写字符。&lt;/p&gt;
&lt;p&gt;（2）nodeName属性指定节点的节点名称。如果节点是元素节点，则 nodeName 属性返回标签名。如果节点是属性节点，则 nodeName 属性返回属性的名称。对于其他节点类型，nodeName 属性返回不同节点类型的不同名称。&lt;/p&gt;
&lt;p&gt;所有主流浏览器均支持 nodeName 属性&lt;/p&gt;
&lt;h1 id=&#34;vue事件修饰符&#34;&gt;Vue事件修饰符&lt;/h1&gt;
&lt;p&gt;在事件处理程序中调用 event.preventDefault()或event.stopPropagation()是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节&lt;/p&gt;
&lt;p&gt;为了解决这个问题，Vue.js 为v-on提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的&lt;/p&gt;
&lt;p&gt;详情参考&lt;a href=&#34;https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6&#34;&gt;Vue事件修饰符&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903834075021326#heading-5&#34;&gt;你真的理解 事件冒泡 和 事件捕获 吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zhuzhenwei918/p/6139880.html&#34;&gt;JavaScript中捕获/阻止捕获、冒泡/阻止冒泡&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/ - </description>
        </item>
    
    
    
        <item>
        <title>重绘、回流</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css-%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/</link>
        <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css-%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css-%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/ -&lt;h1 id=&#34;浏览器渲染&#34;&gt;浏览器渲染&lt;/h1&gt;
&lt;p&gt;浏览器在渲染页面的时候，大致是以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解析html生成DOM树，解析css，生成CSSOM树，将DOM树和CSSOM树结合，生成渲染树；&lt;/li&gt;
&lt;li&gt;根据渲染树，浏览器可以计算出网页中有哪些节点，各节点的CSS以及从属关系 - 【回流】&lt;/li&gt;
&lt;li&gt;根据渲染树以及回流得到的节点信息，计算出每个节点在屏幕中的位置 - 【重绘】&lt;/li&gt;
&lt;li&gt;最后将得到的节点位置信息交给浏览器的图形处理程序，让浏览器中显示页面&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;回流&#34;&gt;回流&lt;/h1&gt;
&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;英文叫reflow，指的是当渲染树中的节点信息发生了大小、边距等问题，需要重新计算各节点和css具体的大小和位置&lt;/p&gt;
&lt;p&gt;例：在css中对一个div修饰的样式中，使用了宽度50%，此时需要将50%转换为具体的像素，这个计算的过程，就是回流的过程&lt;/p&gt;
&lt;h2 id=&#34;容易造成回流的操作&#34;&gt;容易造成回流的操作&lt;/h2&gt;
&lt;h3 id=&#34;1布局流相关操作&#34;&gt;1、布局流相关操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;盒模型的相关操作会触发重新布局&lt;/li&gt;
&lt;li&gt;定位相关操作会触发重新布局&lt;/li&gt;
&lt;li&gt;浮动相关操作会触发重新布局&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2改变节点内的内容&#34;&gt;2、改变节点内的内容&lt;/h3&gt;
&lt;p&gt;改变节点的结构或其中的文本结构会触发重新布局&lt;/p&gt;
&lt;h3 id=&#34;3css&#34;&gt;3、css&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;width&lt;/li&gt;
&lt;li&gt;height&lt;/li&gt;
&lt;li&gt;padding&lt;/li&gt;
&lt;li&gt;border&lt;/li&gt;
&lt;li&gt;margin&lt;/li&gt;
&lt;li&gt;position&lt;/li&gt;
&lt;li&gt;top&lt;/li&gt;
&lt;li&gt;left&lt;/li&gt;
&lt;li&gt;bottom&lt;/li&gt;
&lt;li&gt;right&lt;/li&gt;
&lt;li&gt;float&lt;/li&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;text-align&lt;/li&gt;
&lt;li&gt;vertical-align&lt;/li&gt;
&lt;li&gt;line-height&lt;/li&gt;
&lt;li&gt;font-weight&lt;/li&gt;
&lt;li&gt;font-size&lt;/li&gt;
&lt;li&gt;font-family&lt;/li&gt;
&lt;li&gt;overflow&lt;/li&gt;
&lt;li&gt;white-space&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;重绘&#34;&gt;重绘&lt;/h1&gt;
&lt;h2 id=&#34;概念-1&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;重绘：英文叫repaint，当节点的部分属性发生变化，但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程，就叫重绘&lt;/p&gt;
&lt;p&gt;例：改变元素的背景颜色、字体颜色等操作会造成重绘&lt;/p&gt;
&lt;h2 id=&#34;容易造成重绘操作的css&#34;&gt;容易造成重绘操作的CSS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;color&lt;/li&gt;
&lt;li&gt;border-style&lt;/li&gt;
&lt;li&gt;border-radius&lt;/li&gt;
&lt;li&gt;text-decoration&lt;/li&gt;
&lt;li&gt;box-shadow&lt;/li&gt;
&lt;li&gt;outline&lt;/li&gt;
&lt;li&gt;background&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;优化机制&#34;&gt;优化机制&lt;/h1&gt;
&lt;h2 id=&#34;1浏览器优化&#34;&gt;1、浏览器优化&lt;/h2&gt;
&lt;p&gt;每次回流都会对浏览器造成额外的计算消耗，所以浏览器对于回流和重绘有一定的优化机制&lt;/p&gt;
&lt;p&gt;浏览器通常都会将多次回流操作放入一个队列中，等过了一段时间或操作达到了一定的临界值，然后才会挨个执行，这样能节省一些计算消耗。&lt;/p&gt;
&lt;p&gt;但是在获取布局信息操作的时候，会强制将队列清空，也就是强制回流，比如访问或操作以下或方法时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offsetTop&lt;/li&gt;
&lt;li&gt;offsetLeft&lt;/li&gt;
&lt;li&gt;offsetWidth&lt;/li&gt;
&lt;li&gt;offsetHeight&lt;/li&gt;
&lt;li&gt;scrollTop&lt;/li&gt;
&lt;li&gt;scrollLeft&lt;/li&gt;
&lt;li&gt;scrollWidth&lt;/li&gt;
&lt;li&gt;scrollHeight&lt;/li&gt;
&lt;li&gt;clientTop&lt;/li&gt;
&lt;li&gt;clientLeft&lt;/li&gt;
&lt;li&gt;clientWidth&lt;/li&gt;
&lt;li&gt;clientHeight&lt;/li&gt;
&lt;li&gt;getComputedStyle()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些属性或方法都需要得到最新的布局信息，所以浏览器必须去回流执行。因此，在项目中，尽量避免使用上述属性或方法，如果非要使用的时候，也尽量将值缓存起来，而不是一直获取&lt;/p&gt;
&lt;h2 id=&#34;2合并样式修改&#34;&gt;2、合并样式修改&lt;/h2&gt;
&lt;p&gt;减少造成回流的次数，如果要给一个节点操作多个css属性，而每一个都会造成回流的话，尽量将多次操作合并成一个，例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; oDiv &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.querySelector(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;.box&amp;#39;&lt;/span&gt;)
oDiv.style.padding &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;5px&amp;#39;&lt;/span&gt;
oDiv.style.border &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;1px solid #000&amp;#39;&lt;/span&gt;
oDiv.style.margin &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;5px&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;操作div的3个css属性，分别是padding、border、margin，此时就可以考虑将多次操作合并为一次&lt;/p&gt;
&lt;p&gt;方法一：使用style的cssText&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;oDiv.style.cssText &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;padding:5px; border:1px solid #000; margin:5px;&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;方法二：将这几个样式定义给一个类名，然后给标签添加类名&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;style&lt;/span&gt;&amp;gt;
    .&lt;span style=&#34;color:#50fa7b&#34;&gt;pbm&lt;/span&gt;{
        &lt;span style=&#34;color:#ff79c6&#34;&gt;padding&lt;/span&gt;:&lt;span style=&#34;color:#bd93f9&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;px&lt;/span&gt;; 
        &lt;span style=&#34;color:#ff79c6&#34;&gt;border&lt;/span&gt;:&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;solid&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;#000&lt;/span&gt;; 
        &lt;span style=&#34;color:#ff79c6&#34;&gt;margin&lt;/span&gt;:&lt;span style=&#34;color:#bd93f9&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;px&lt;/span&gt;;
    }
&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;style&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;script&lt;/span&gt;&amp;gt;
    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; oDiv &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.querySelector(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;.box&amp;#39;&lt;/span&gt;);
    oDiv.classList.add(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;pbm&amp;#39;&lt;/span&gt;);
&amp;lt;/&lt;span style=&#34;color:#ff79c6&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3批量操作dom&#34;&gt;3、批量操作DOM&lt;/h2&gt;
&lt;p&gt;当对DOM有多次操作的时候，需要使用一些特殊处理减少触发回流，其实就是对DOM的多次操作，在脱离标准流后，对元素进行的多次操作，不会触发回流，等操作完成后，再将元素放回标准流&lt;/p&gt;
&lt;p&gt;脱离标准流的操作有以下3中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;隐藏元素&lt;/li&gt;
&lt;li&gt;使用文档碎片&lt;/li&gt;
&lt;li&gt;拷贝节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例：下面对DOM节点的多次操作，每次都会触发回流&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; data &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; [
    {
        id&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;,
        name&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;商品1&amp;#34;&lt;/span&gt;
    },
    {
        id&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;2&lt;/span&gt;,
        name&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;商品1&amp;#34;&lt;/span&gt;
    },
    {
        id&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;3&lt;/span&gt;,
        name&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;商品1&amp;#34;&lt;/span&gt;
    },
    {
        id&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;4&lt;/span&gt;,
        name&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;商品1&amp;#34;&lt;/span&gt;
    }
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 假设后面还有很多
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;]
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; oUl &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.querySelector(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;ul&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; i&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;data.length;i&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;){
    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; oLi &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.createElement(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;li&amp;#34;&lt;/span&gt;)
    oLi.innerText &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; data[i].name
    oUl.appendChild(oLi)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样每次给ul中新增一个li的操作，每次都会触发回流。&lt;/p&gt;
&lt;p&gt;方法一：隐藏ul后，给ul添加节点，添加完成后再将ul显示&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;oUl.style.display &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;none&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; i&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;data.length;i&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;){
    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; oLi &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.createElement(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;li&amp;#34;&lt;/span&gt;)
    oLi.innerText &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; data[i].name
    oUl.appendChild(oLi)
}
oUl.style.display &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;block&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，在隐藏ul和显示ul的时候，触发了两次回流，给ul添加每个li的时候没有触发回流。&lt;/p&gt;
&lt;p&gt;方法二：创建文档碎片，将所有li先放在文档碎片中，等都放进去以后，再将文档碎片放在ul中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; fragment &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.createDocumentFragment()
&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; i&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;data.length;i&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;){
    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; oLi &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.createElement(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;li&amp;#34;&lt;/span&gt;)
    oLi.innerText &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; data[i].name
    fragment.appendChild(oLi)
}
oUl.appendChild(fragment)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;方法三：将ul拷贝一份，将所有li放在拷贝中，等都放进去以后，使用拷贝替换掉ul&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; newUL &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; oUl.cloneNode(&lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;);
&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; i&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;data.length;i&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;){
    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; oLi &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.createElement(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;li&amp;#34;&lt;/span&gt;);
    oLi.innerText &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; data[i].name;
    newUL.appendChild(oLi);
}
oUl.parentElement.replaceChild(newUl, oUl);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4避免多次触发布局&#34;&gt;4、避免多次触发布局&lt;/h2&gt;
&lt;p&gt;例：如下回到顶部的操作&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;goBack.onclick &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(){
    setInterval(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(){
        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; t &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.documentElement.scrollTop &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.body.scrollTop
        t &lt;span style=&#34;color:#ff79c6&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;10&lt;/span&gt;
        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.documentElement.scrollTop &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.body.scrollTop &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; t
    },&lt;span style=&#34;color:#bd93f9&#34;&gt;20&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每隔20毫秒都会重新获取滚动过的距离，每次都会触发回流，代码优化如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;goBack.onclick &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(){
    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; t &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.documentElement.scrollTop &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.body.scrollTop
    setInterval(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt;(){
        t &lt;span style=&#34;color:#ff79c6&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;10&lt;/span&gt;
        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.documentElement.scrollTop &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;document&lt;/span&gt;.body.scrollTop &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; t
    },&lt;span style=&#34;color:#bd93f9&#34;&gt;20&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;只获取一次，每次都让数字递增，避免每次都获取滚动过的距离&lt;/p&gt;
&lt;p&gt;对于页面中比较复杂的动画，尽量将元素设置为绝对定位，操作元素的定位属性，这样只有这一个元素会回流，如果不是定位的话，容易引起其父元素以及子元素的回流&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/342371522&#34;&gt;讲清楚重排或回流、重绘&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css-%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/ - </description>
        </item>
    
    
    
        <item>
        <title>Vue2-token</title>
        <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-token/</link>
        <pubDate>Fri, 06 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-token/</guid>
        <description>DaMuWang https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-token/ -&lt;h1 id=&#34;token的含义&#34;&gt;token的含义&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;1、Token的引入：
Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。&lt;/p&gt;
&lt;p&gt;2、Token的定义：
Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。&lt;/p&gt;
&lt;p&gt;3、使用Token的目的：
Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。&lt;/p&gt;
&lt;p&gt;4、Token 的优点：
扩展性更强，也更安全点，非常适合用在 Web 应用或者移动应用上。Token 的中文有人翻译成 “令牌”，我觉得挺好，意思就是，你拿着这个令牌，才能过一些关卡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;项目中使用token&#34;&gt;项目中使用token&lt;/h1&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名称&lt;/th&gt;
&lt;th&gt;功能描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;auth.js&lt;/td&gt;
&lt;td&gt;设置、获取以及清空cookie&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;http.js&lt;/td&gt;
&lt;td&gt;接口请求封装&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;store.js&lt;/td&gt;
&lt;td&gt;对接业务的状态管理，负责登录、登出状态的保存和移除&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;流程梳理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户输入信息点击登录，调用store.js中的Login方法请求登录接口，调用成功返回200回传token值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着调用SaveLoginInfo方法，将token值state中保存一份，再调用setToken将token在cookie中也保存一份&lt;/p&gt;
&lt;p&gt;因为vuex刷新页面数据会丢，所以在cookie里面也放了一份，使用的时候只需要通过getter方法获取state就可以，state默认值为调用getToken获取的cookie中的token值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时token对象就可以全局使用了，除登录以外的所有接口请求都要传token，否则会报505错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;token由服务端生成，设置了失效时间为24小时&lt;/p&gt;
&lt;p&gt;当token过期，前端再发送请求，服务端会返回505，此响应会被http.js的拦截器捕获&lt;/p&gt;
&lt;p&gt;捕获后先弹框提示‘登录信息已过期，请重新登录&amp;rsquo;，接着调用store.js中的ClearLoginInfo方法清空state中全局token，再调用removeToken移除cookie&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清空完之后会执行跳转，重新回到登录页面重复步骤一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;退出登录与登录操作类似，用户点击退出登录按钮，调用store.js里的ClearLoginInfo方法。先清空state中全局token，再调用removeToken移除cookie&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码&lt;/p&gt;
&lt;p&gt;auth.js&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;import&lt;/span&gt; Cookies from &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;js-cookie&amp;#39;&lt;/span&gt;

&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; TokenKey &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;sxmanage-auth-token&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// tokenKey为固定字符串
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#6272a4&#34;&gt;// 根据TokenKey获取cookie中的token信息
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; getToken () {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; Cookies.get(TokenKey)
}
&lt;span style=&#34;color:#6272a4&#34;&gt;// 设置将token设置到cookie中
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; setToken (token) {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; Cookies.set(TokenKey, token)
}
&lt;span style=&#34;color:#6272a4&#34;&gt;// 根据tTokenKey移除cookie中的token信息
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;function&lt;/span&gt; removeToken () {
  &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; Cookies.remove(TokenKey)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;http.js&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;import&lt;/span&gt; axios from &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;axios&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;import&lt;/span&gt; store from &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;@/store&amp;#39;&lt;/span&gt;

&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; service &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; axios.create({
    timeout&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;30000&lt;/span&gt;, &lt;span style=&#34;color:#6272a4&#34;&gt;// request timeout
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    withCredentials&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
})

&lt;span style=&#34;color:#6272a4&#34;&gt;// resposne interceptor
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;service.interceptors.response.use(
    response =&amp;gt; {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; res &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; response.data
        &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (res.c &lt;span style=&#34;color:#ff79c6&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;505&lt;/span&gt;)  {
            alert(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;登录信息已过期，请重新登录&amp;#39;&lt;/span&gt;)
            &lt;span style=&#34;color:#6272a4&#34;&gt;// 清除数据
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;            store.dispatch(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;ClearLoginInfo&amp;#39;&lt;/span&gt;).then(() =&amp;gt; {
                &lt;span style=&#34;color:#6272a4&#34;&gt;// 跳转到登录页面
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;                router.push(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;/login&amp;#39;&lt;/span&gt;)
            })
        }
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; response
    }, error =&amp;gt; {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;.reject(error)
    }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;store.js&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;import&lt;/span&gt; Vuex from &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;vuex&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;import&lt;/span&gt; Vue from &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;vue&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;import&lt;/span&gt; { base } from &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;@/api/base&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;import&lt;/span&gt; { getToken, setToken, removeToken} from &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;@/utils/auth&amp;#39;&lt;/span&gt;

Vue.use(Vuex)

&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; state &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
  token&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; getToken()
}

&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; getters &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
  token&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; state =&amp;gt; state.token
}

&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; mutations &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
  SET_TOKEN&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; (state, token) =&amp;gt; {
    state.token &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; token
  }
}

&lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; actions &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {
  &lt;span style=&#34;color:#6272a4&#34;&gt;/** 登录 */&lt;/span&gt;
  Login&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; ({ commit, dispatch }, userInfo) =&amp;gt; {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
      base.login(userInfo).then(response =&amp;gt; {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (response.data.c &lt;span style=&#34;color:#ff79c6&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;200&lt;/span&gt;) {
          &lt;span style=&#34;color:#6272a4&#34;&gt;// 先清除数据
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;          dispatch(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;ClearLoginInfo&amp;#39;&lt;/span&gt;)
          &lt;span style=&#34;color:#6272a4&#34;&gt;// 再保存数据
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;          dispatch(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;SaveLoginInfo&amp;#39;&lt;/span&gt;, response.data)
          resolve(response.data)
        } &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
          reject(response.data.c)
        }
      })
    })
  },
  &lt;span style=&#34;color:#6272a4&#34;&gt;// 保存登录信息
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  SaveLoginInfo&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; ({ commit }, data) =&amp;gt; {
    &lt;span style=&#34;color:#6272a4&#34;&gt;// state保存token
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    commit(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;SET_TOKEN&amp;#39;&lt;/span&gt;, data.v.token)
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 保存token到cookie中
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    setToken(data.v.token)
  },
  &lt;span style=&#34;color:#6272a4&#34;&gt;/** 清除数据 */&lt;/span&gt;
  ClearLoginInfo&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; ({ commit }) =&amp;gt; {
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 清除数据
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    commit(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;SET_TOKEN&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;)
    &lt;span style=&#34;color:#6272a4&#34;&gt;// 清除cookie中的token
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    removeToken()
  }
}

&lt;span style=&#34;color:#ff79c6&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; Vuex.Store({
  state,
  getters,
  mutations,
  actions
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/cmj6706/article/details/79032703&#34;&gt;token详解以及应用原理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
- https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-token/ - </description>
        </item>
    
    
  </channel>
</rss> 