<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on DaMuWang</title>
    <link>https://damuwangs.github.io/tags/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on DaMuWang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 11 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://damuwangs.github.io/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>开发技巧-上海龙品信息（管理平台）</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E4%B8%8A%E6%B5%B7%E9%BE%99%E5%93%81%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E4%B8%8A%E6%B5%B7%E9%BE%99%E5%93%81%E4%BF%A1%E6%81%AF/</guid>
      <description>管理平台 左侧树结构 根目录：leftTreeRightTemplate.vue
根配置：leftTreeRightTemplate.config
树组件：components=&amp;gt;navigatorTree.vue
通用列表配置 根目录：list.vue
根配置：list.config.js
action配置：list.action.js
查询条件配置：list.fields.js
经常用到的配置或方法   权限判断，权限key为权限-&amp;gt;资源管理中配置
this.$checkPr(&amp;#39;orderList-tab-outStockOrder&amp;#39;)   在子js文件中获取根目录下的变量
this.getScopeRoot().xxx   </description>
    </item>
    
    <item>
      <title>Webpack4-基础与配置</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/webpack4-%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/webpack4-%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid>
      <description>概念 安装与配置 插件 权限实现 用户登录成功时会调用GetMenuInfo，获取当前登录账户的所有权限，并将权限放入全局状态和缓存
/** * @description: 查询当前登录用户权限数据 * @param {object} data 登录返回token * @return {promise} */ GetMenuInfo: ({ commit }, data) =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { let subData = { &amp;#39;tk&amp;#39;: data.v.token } // 请求服务端返回当前登录用户的权限数据  base.getMenuInfo(subData).then(response =&amp;gt; { // 保存system到state中  commit(&amp;#39;SET_SYSTEMS&amp;#39;, response.data.v.SystemList) storage.setLocalStorage(&amp;#39;SYSTEMS&amp;#39;, response.data.v.SystemList) // 保存menu到state中  commit(&amp;#39;SET_MENUS&amp;#39;, response.data.v.MenuList) storage.setLocalStorage(&amp;#39;MENUS&amp;#39;, response.data.v.MenuList) // 保存function到state中  commit(&amp;#39;SET_FUNCTIONS&amp;#39;, response.data.v.FunctionList) storage.setLocalStorage(&amp;#39;FUNCTIONS&amp;#39;, response.data.v.FunctionList) resolve() }).catch(error =&amp;gt; { reject(error) }) }) 退出时会清空所有全局状态和缓存</description>
    </item>
    
    <item>
      <title>Vue2-权限控制</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</guid>
      <description>权限配置 devTools 是一个独立部署的前端权限，接口配置工具。主要分为四层
 平台Platform：确保此工具可以跨项目使用，不用每一个项目再部署一套 系统system：每个平台下的左侧系统，一般同一个类型的功能会放在一个系统里 菜单menu：点击后跳转页面的具体菜单 功能function：主要指页面上的操作按钮，这里会配置对应的后台服务和接口名称  配置  在devTools依次维护平台、系统、菜单和功能项 系统会预留一个拥有所有权限的管理账户 登录管理员账户进入系统管理功能新增角色，权限会以树的形式进行多选展示 进入员工管理功能录入基本信息，角色信息会以一个多选的checkbox进行勾选 将创建好的员工分配给具体用户  权限实现 用户登录成功时会调用GetMenuInfo，获取当前登录账户的所有权限，并将权限放入全局状态和缓存
/** * @description: 查询当前登录用户权限数据 * @param {object} data 登录返回token * @return {promise} */ GetMenuInfo: ({ commit }, data) =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { let subData = { &amp;#39;tk&amp;#39;: data.v.token } // 请求服务端返回当前登录用户的权限数据  base.getMenuInfo(subData).then(response =&amp;gt; { // 保存system到state中  commit(&amp;#39;SET_SYSTEMS&amp;#39;, response.data.v.SystemList) storage.setLocalStorage(&amp;#39;SYSTEMS&amp;#39;, response.data.v.SystemList) // 保存menu到state中  commit(&amp;#39;SET_MENUS&amp;#39;, response.data.v.MenuList) storage.</description>
    </item>
    
    <item>
      <title>面试-2022年3月</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/%E9%9D%A2%E8%AF%95-2022%E5%B9%B43%E6%9C%88/</link>
      <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/%E9%9D%A2%E8%AF%95-2022%E5%B9%B43%E6%9C%88/</guid>
      <description>JavaScript   移动端事件延迟 原因：移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面
 禁用缩放： 浏览器禁用默认的双击缩放行为并且去掉300ms 的点击延迟  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;user-scalable=no&amp;#34;&amp;gt; 利用touch事件自己封装这个事件解决300ms 延迟  原理就是：
当我们手指触摸屏幕，记录当前触摸时间
当我们手指离开屏幕， 用离开的时间减去触摸的时间
如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击
代码如下:
//封装tap，解决click 300ms 延时 function tap (obj, callback) { var isMove = false; var startTime = 0; // 记录触摸时候的时间变量  obj.addEventListener(&amp;#39;touchstart&amp;#39;, function (e) { startTime = Date.now(); // 记录触摸时间  }); obj.addEventListener(&amp;#39;touchmove&amp;#39;, function (e) { isMove = true; // 看看是否有滑动，有滑动算拖拽，不算点击  }); obj.</description>
    </item>
    
    <item>
      <title>【待补充】React-Hook</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-hook/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-hook/</guid>
      <description>为什么需要Portals Portals能够将子组件渲染到父组件以外的DOM树，他通常用于子组件需要从父组件的容器中脱离出来的场景，有以下场景：
参考资料  传送门：React Portal
你真的了解React Portals吗
 </description>
    </item>
    
    <item>
      <title>【待补充】React-RenderProps</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-renderprops/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-renderprops/</guid>
      <description>为什么需要Portals Portals能够将子组件渲染到父组件以外的DOM树，他通常用于子组件需要从父组件的容器中脱离出来的场景，有以下场景：
参考资料  传送门：React Portal
你真的了解React Portals吗
 </description>
    </item>
    
    <item>
      <title>React-Portals</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-portals/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-portals/</guid>
      <description>为什么需要Portals Portals能够将子组件渲染到父组件以外的DOM树，他通常用于子组件需要从父组件的容器中脱离出来的场景，有以下场景：
 Dialog对话框 Tooltip文字提示 Popover弹出框 Loader全局loader  比如某个组件在渲染时，在某种条件下需要显示一个Dialog，最直观的做法，就是直接在JSX中把Dialog画出来，像下面代码的样子
&amp;lt;div class=&amp;#34;foo&amp;#34;&amp;gt; &amp;lt;div&amp;gt; ... &amp;lt;/div&amp;gt; { needDialog ? &amp;lt;Dialog /&amp;gt; : null } &amp;lt;/div&amp;gt; 问题是，Dialog最终渲染产生的HTML就与上面JSX产生的HTML产生嵌套了，类似下面这样
&amp;lt;div class=&amp;#34;foo&amp;#34;&amp;gt; &amp;lt;div&amp;gt; ... &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;dialog&amp;#34;&amp;gt;Dialog Content&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 对于对话框应该是一个独立的组件，通常应该显示在屏幕的最中间，现在Dialog被包在其它组件中，要用CSS的position属性控制Dialog位置，就要从Dialog往上一直到body都没有其它position是relative的元素干扰。还有一点，Dialog的样式，因为包含在其它元素中，各种样式纠缠，CSS样式太容易搞成一坨浆糊了。
我们既希望在组件的JSX中选择使用Dialog，把Dialog用的像普通组件一样，但是又希望Dialog内容显示在另一个地方，就需要Portals上场了。
Portals就是建立一个“传送门”，让Dialog这样的组件在表示层和其它组件没有任何差异，但是渲染的东西却像经过传送门一样出现在另一个地方
当我们需要在正常的DOM结构之外呈现子组件时，React Portals非常有用，而不需要通过React组件树层次结构破坏事件传播的默认行为，这在渲染例如弹窗、提示时非常有用
React v16的Portals支持 在某个组件中需要使用modal弹框，大多数情况下可以使用fixed定位让这个弹框全局展示，但是特殊情况下，这个modal弹框可能会显示不正常。这个时候如果使用了portals的方式，使modal的dom结构脱离父组件的容器，就可以规避这种问题
// 定义弹框组件 const Modal = ({message, isOpen, onClose, children}) =&amp;gt; { if (!isOpen) return null // 创建portals并挂载到body中  return ReactDOM.createPortal( &amp;lt;div className=&amp;#34;modal&amp;#34;&amp;gt; &amp;lt;span&amp;gt;{message}&amp;lt;/span&amp;gt; &amp;lt;button onClick={onClose}&amp;gt;Close&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; , document.body) } // 弹框使用 function Component() { const [open, setOpen] = useState(false) return ( &amp;lt;div className=&amp;#34;component&amp;#34;&amp;gt; &amp;lt;button onClick={() =&amp;gt; setOpen(true)}&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;Modal message=&amp;#34;Hello World!</description>
    </item>
    
    <item>
      <title>Html-meta标签</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/html-meta%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/html-meta%E6%A0%87%E7%AD%BE/</guid>
      <description>概念  元数据(metadata)是关于数据的信息
标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。
典型的情况是，meta元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。
标签始终位于head元素中。
元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或者其他web服务
 属性 必需属性 meta的必须属性是content，并不是说meta标签里一定要有content，而是当有http-equiv或name属性的时候，一定要有content属性对其进行说明。
例：
&amp;lt;meta name=&amp;#34;keywords&amp;#34; content=&amp;#34;HTML,ASP,PHP,SQL&amp;#34;&amp;gt; 可选属性 http-equiv 添加http头部内容，对一些自定义的，或者需要额外添加的http头部内容，需要发送到浏览器中，我们就可以使用这个属性。
例如我们不想使用js来重定向，用http头部内容控制，就可以这样控制
&amp;lt;meta http-equiv=&amp;#34;Refresh&amp;#34; content=&amp;#34;5;url=http://www.baidu.com&amp;#34; /&amp;gt; 在页面head中加入这个后，5秒钟后就会跳转到指定的页面
name 供浏览器进行解析，对于一些浏览器兼容性问题，name是最常用的，当然有个前提就是浏览器能够解析你写进去的name属性才可以
例：
&amp;lt;meta name=&amp;#34;renderer&amp;#34; content=&amp;#34;webkit&amp;#34;&amp;gt; 这个meta标签的意思就是告诉浏览器，用webkit内核进行解析，前提是浏览器有webkit内核才可以。当然看到这个你可能会有疑问，这个renderer是从哪里冒出来的？这个就是在对应的浏览器的开发文档里就会有表明的，例如这个renderer是在360浏览器里说明的。360浏览器内核控制Meta标签说明文档
meta标签总结 charset 声明文档使用的字符编码，解决乱码问题主要用的就是它，值得一提的是，这个charset一定要写第一行，不然可能会产生乱码了。
chartset有两种写法
&amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=utf-8&amp;#34;&amp;gt; SEO 优化部分 &amp;lt;!-- 页面标题&amp;lt;title&amp;gt;标签(head 头部必须) --&amp;gt; &amp;lt;title&amp;gt;your title&amp;lt;/title&amp;gt; &amp;lt;!-- 页面关键词 keywords --&amp;gt; &amp;lt;meta name=&amp;#34;keywords&amp;#34; content=&amp;#34;your keywords&amp;#34;&amp;gt; &amp;lt;!-- 页面描述内容 description --&amp;gt; &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;your description&amp;#34;&amp;gt; &amp;lt;!-- 定义网页作者 author --&amp;gt; &amp;lt;meta name=&amp;#34;author&amp;#34; content=&amp;#34;author,email address&amp;#34;&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>React-高阶组件</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</guid>
      <description>概念 一个高阶组件只是一个包装了另外一个React组件的React组件
基础高阶组件 装饰器模式 高阶组件可以看做是装饰器模式(Decorator Pattern)在React的实现。即允许向一个现有的对象添加新的功能，同时又不改变其结构，属于包装模式(Wrapper Pattern)的一种
// 定义高阶组件 const withHeader = (WrappedComponent) =&amp;gt; class extends React.Component { render() { return ( &amp;lt;div&amp;gt; &amp;lt;div className=&amp;#34;demo-header&amp;#34;&amp;gt;高阶组件&amp;lt;/div&amp;gt; &amp;lt;WrappedComponent {...this.props}/&amp;gt; &amp;lt;/div&amp;gt; ) } } // 调用高阶组件 @withHeader class Demo extends React.Component { render() { return ( &amp;lt;div&amp;gt;普通组件&amp;lt;/div&amp;gt; ) } } 组件命名 当通过高阶组件来包装一个组件时，你会丢失原先 WrappedComponent 的名字，可能会给开发和 debug 造成影响
我们改写一下上述的高阶组件代码，增加了getDisplayName函数以及静态属性displayName，此时再去观察DOM Tree
// 获取组件名称 function getDisplayName(component) { return component.displayName || component.name || &amp;#39;Component&amp;#39; } // 定义高阶组件 const withHeader = WrappedComponent =&amp;gt; class extends React.</description>
    </item>
    
    <item>
      <title>UniApp-App签名</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/uniapp-app%E7%AD%BE%E5%90%8D/</link>
      <pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/uniapp-app%E7%AD%BE%E5%90%8D/</guid>
      <description>为什么要有签名 开发Android的人这么多，完全有可能把类名，包名命名成同样的名字，这个时候该如何区分？所以，这时候就需要签名来区分了，由于开发商可能通过使用相同的Package Name来混淆替换已经安装的程序，签名可以保证报名相同，但是签名不同的包不被替换。 发布过Android应用的朋友们应该都知道，Android APK的发布是需要签名的。签名机制在Android应用和框架中有着十分重要的作用。例如，Android系统禁止更新安装签名不一致的APK；如果应用需要使用system权限，必须保证APK签名与Framework签名一致
注意事项 应用程序签名的一些方面可能会影响应用程序的开发过程, 尤其是当你计划发布多个应用时. 通常情况下, 对于所有开发者而言,推荐的策略是:在应用程序的整个生命周期,所有的应用程序使用相同的证书签名.
 应用程序升级 – 当发布应用的更新时, 如果想让用户无缝地升级到新版本, 需要继续使用相同的某个或者某一套证书来签名更新包.当系统安装应用的更新时, 它会比较现有版本和新版本的证书. 如果证书吻合, 包括证书数据和顺序都吻合, 那么系统允许更新.如果新版本所做的签名不是匹配的, 那么将需要给应用起一个不同的包名 — 在这种情况下, 用户相当于安装了一个完全的新程序. 应用程序模块化 – Android允许由相同证书签名的应用程序运行在相同的进程中, 此时系统会将它们作为单个应用程序对待.在这种方式中, 可以按模块化的方式部署应用, 用户可以根据需要独立地更新每一个模块. 代码/数据 的授权共享 – Android 提供模式匹配的权限控制机制,因此一个应用可以暴露功能给另一个用指定证书签名的应用. 通过用相同证书签名多个应用,以及使用模式匹配的权限检查,应用程序可以以安全的方式共享代码和数据.  参考资料  Android中签名、证书、公钥密钥的概念及使用
 </description>
    </item>
    
    <item>
      <title>JavaScript-MVC、MVVM模式</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-mvcmvvm%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 08 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-mvcmvvm%E6%A8%A1%E5%BC%8F/</guid>
      <description>概念 模型（Model）：指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。后端的处理通常会非常复杂
视图（View）：视图部分，通常指html等用来对用户展示的一部分
控制器（Controller）：负责根据用户从&amp;quot;视图层&amp;quot;输入的指令，选取&amp;quot;数据层&amp;quot;中的数据，然后对其进行相应的操作，产生最终结果
视图模型（ViewModel）：由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示），而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现数据驱动开发。看到了吧，View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环
MVC  用户端操作View ，Js监听事件绑定DOM数据，传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变数据状态 Model 将新的数据发送到 View，通过JS操作DOM为View赋值，用户得到反馈   如果前端没有框架，只使用原生的html+js，MVC模式可以这样理解：
  将html看成view
  js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）
  将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据
   MVVM 就像分析MVC是如何合理分配工作的一样，我们需要数据所以有了M，我们需要界面所以有了V，而我们需要找一个地方把M赋值给V来显示，所以有了C，然而我们忽略了一个很重要的操作：数据解析。在MVC出生的年代，手机APP的数据往往都比较简单，没有现在那么复杂，所以那时的数据解析很可能一步就解决了，所以既然有这样一个问题要处理，而面向对象的思想就是用类和对象来解决问题，显然V和M早就被定义死了，它们都不应该处理“解析数据”的问题，理所应当的，“解析数据”这个问题就交给C来完成了。而现在的手机App功能越来越复杂，数据结构也越来越复杂，所以数据解析也就没那么简单了。如果我们继续按照MVC的设计思路，将数据解析的部分放到了Controller里面，那么Controller就将变得相当臃肿。还有相当重要的一点：Controller被设计出来并不是处理数据解析的。1、管理自己的生命周期；2、处理Controller之间的跳转；3、实现Controller容器。这里面根本没有“数据解析”这一项，所以显然，数据解析也不应该由Controller来完成。那么我们的MVC中，M、V、C都不应该处理数据解析，那么由谁来呢？这个问题实际上在面向对象的时候相当好回答：既然目前没有类能够处理这个问题，那么就创建一个新的类出来解决不就好了？所以我们聪明的开发者们就专门为数据解析创建出了一个新的类：ViewModel。这就是MVVM的诞生
 用户端操作View，ViewModel监听视图变化，触发绑定事件 ViewModel组织好数据，请求服务端处理业务逻辑调用Model层操作数据 服务端处理完数据及逻辑后，要求 Model 改变数据状态 ViewModel组装结果数据后自动绑定到View层，用户得到反馈  思考   ViewModel和Controller的区别</description>
    </item>
    
    <item>
      <title>UniApp-原生插件开发</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/uniapp-%E5%8E%9F%E7%94%9F%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</link>
      <pubDate>Wed, 20 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/uniapp-%E5%8E%9F%E7%94%9F%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</guid>
      <description>一、开发环境 Java环境1.8 参考：jdk1.8下载与安装教程
Android环境  软件下载    下载SDK Tools
  下载完成点击SDK Manager.exe运行
  需要下载以下插件
  环境变量配置    系统变量下添加变量
ANDROID_SDK_HOME，指向Android SDK根目录   Path新增:
Android SDK根目录\platform-tools; Android SDK根目录\tools;   命令行测试是否配置成功
adb (成功后可以看到adb的版本号及命令行说明等信息)   AndroidStudio 参考：Android Studio官网
demo下载 参考：Android 离线SDK - 正式版
二、AndroidStudio运行 项目导入   点击Android Studio菜单选项File—&amp;gt;New—&amp;gt;Import Project
  导入选择UniPlugin-Hello-As工程，点击OK！等待工程导入完毕
  导入后切换为Android项目结构，目录如下
  生成签名文件   点击Build—&amp;gt;Generate Signed Apk</description>
    </item>
    
    <item>
      <title>Vue2-响应式原理</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 13 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</guid>
      <description>概述 Vue采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式，
监听属性变化
 Vue在初始化的时候，对data对象进行遍历，在这个方法中会调Observe（监听器，观察者）对用户的数据进行监听 在observe中对数据进行判断，对对象进行循环，使用defineReactive，它是vue中的一个核心方法，用来定义响应式 defineReactive方法中实例化了一个Dep（发布者），通过Object.defineProperty对数据进行拦截，把这些 property 全部转为 getter/setter。get数据的时候，通过dep.depend触发Watcher（订阅者）的依赖收集，收集订阅者；set时，会对数据进行比较，如果数据发生了变化会通过dep.notify发布通知，通知Watcher，更新视图  解析指令
  Vue在初始化时传入当前Vue实例和html根节点的元素标识，进行模板解析
  首先会取出模板元素将其转化成fragment编译后统一进行dom挂载，这样做比较高效（此为虚拟dom）
  循环从fragment取出所有元素子节点，进行指令类型判断（以v-text为例），传入指令类型和属性值调用update方法
  update方法中会将视图与vue实例的data属性绑定渲染页面数据。
当data属性值发生变化会被defineReactive监听到，然后通知wctaher绑定新的数据更新视图
  代码 template &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;!-- 双向绑定 --&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; v-model=&amp;#34;name&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; 监听属性变化 初始化vue时会传入一个json格式的对象
let vue = new Vue({ el: &amp;#39;#app&amp;#39;, data: { name: &amp;#34;name&amp;#34;, } }) 取出该对象并遍历data数据，使用Object.defineProperty()方法来监听每一个属性的变化
observe(value){ if (!value || typeof value !== &amp;#39;object&amp;#39;) { return } //遍历data  Object.keys(value).forEach(key =&amp;gt;{ this.defineReactive(value,key,value[key]) // 代理data中的属性到vue实例上  this.</description>
    </item>
    
    <item>
      <title>Vue2-路由传参，页面刷新后参数类型改变</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E5%90%8E%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%94%B9%E5%8F%98/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E5%90%8E%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%94%B9%E5%8F%98/</guid>
      <description>问题描述 今天发现一个小问题，列表通过路由传递的 number 类型参数，用 === 来判断
Number(this.$route.query.type) !== 1 结果发现有时候为 true ，有时候为 false
进入页面，打印参数类型：
number 刷新页面，打印参数类型：
string 后来发现，原因是：
 vue-router 传参，不管是 params 形式还是query形式传参，在页面刷新后，params 和 query 对象中的属性所对应的属性值都会被浏览器自身强制转换为string类型 (这一点与浏览器的sessionStorage和localStorage存储对象，对象会被转为string类型，不谋而合)，破环原先属性值的数据类型
 解决方案 将参数强制转为 Number类型：
Number(this.$route.query.type) 总结 1、number数据类型：页面刷新后，其类型会转换为 string 类型。
所以，在路由刷新页面，在使用时，不管页面是否刷新，都对传递过来的属性值做一次Number()转换；
2、string数据类型：页面刷新后，其类型依然为string类型；
3、boolean数据类型：页面刷新后，其类型会转换为string类型。
所以，在路由刷新页面，在使用时，不管页面是否刷新，都对传递过来的属性值做一次Boolean()转换；
4、undefined数据类型：页面刷新后，其类型依然为undefined类型；
5、null数据类型：页面刷新后，其类型依然为null类型；
6、object数据类型：页面刷新后，其类型会转换为string类型；
所以，在路由跳转传参页面对属性值做一次JSON.stringify()预处理，然后在路由刷新页面对该值进行JSON.parse()转换。
参考资料  vue 路由传参，页面刷新后参数类型改变_且听风吟的博客-CSDN博客
 </description>
    </item>
    
    <item>
      <title>GitHub个人访问令牌创建与使用</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/github%E4%B8%AA%E4%BA%BA%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/github%E4%B8%AA%E4%BA%BA%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>前言 2020 年 7 月，GitHub官方宣布对所有经过身份验证的 Git 操作，使用基于令牌的身份验证（例如，个人访问、OAuth 或 GitHub 应用程序安装令牌）。
从 2021 年 8 月 13 日开始，将在 GitHub.com 上对 Git 操作进行身份验证时不再接受帐户密码
因此对于开发人员来说，如果无法再用密码对 GitHub.com 的 Git 操作进行身份验证，则必须通过 HTTPS（推荐）或 SSH 密钥开始使用个人访问令牌，以避免中断
创建个人访问令牌   登录GitHub点击头像，下拉选择settings选项   点击Developer settings菜单进入开发者设置   点击PersonAccessTokens菜单进入个人令牌界面   点击GenerateNewToken生成新的令牌 令牌过期使用git拉取代码会报一个鉴权失败的错误，无法推送代码
  修改本地Git账户配置   进入控制面板-凭据管理器，点击Windows凭据   可以看到普通凭据列表有一堆地址，找到GitHub对应的普通凭据 点击编辑设置密码为GitHub申请的个人令牌
  参考资料  GitHub创建个人访问令牌教程
 </description>
    </item>
    
    <item>
      <title>JavaScript-正则</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E6%AD%A3%E5%88%99/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E6%AD%A3%E5%88%99/</guid>
      <description>字符串匹配single char 单个字符 最简单的正则表达式可以由简单的数字和字母组成，没有特殊的语义，纯粹就是一一对应的关系。如想在&amp;rsquo;apple&amp;rsquo;这个单词里找到‘a&amp;rsquo;这个字符，就直接用/a/这个正则就可以了。
但是如果想要匹配特殊字符的话，就要使用元字符\， 它是转义字符字符，顾名思义，就是让其后续的字符失去其本来的含义。举个例子：
我想匹配*这个符号，由于*这个符号本身是个特殊字符，所以我要利用转义元字符\来让它失去其本来的含义
/\*/ 如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等, 而这些就需要我们使用转义字符来匹配
   特殊字符 正则表达式     换行符 \n   换页符 \f   回车符 \r   空白符 \s   制表符 \t   垂直制表符 \v   回退符 [\b]    // \s代表匹配空格，abc为匹配&amp;#39;abc&amp;#39;字符串 const reg = /\sabc/ console.log(reg.test(&amp;#39; abc&amp;#39;)) // true 多个字符 单个字符的映射关系是一对一的，即正则表达式的被用来筛选匹配的字符只有一个。而这显然是不够的，只要引入集合区间和通配符的方式就可以实现一对多的匹配了。
在正则表达式里，集合的定义方式是使用中括号[和]。如/[123]/这个正则就能同时匹配1,2,3三个字符。那如果我想匹配所有的数字怎么办呢？从0写到9显然太过低效，所以元字符-就可以用来表示区间范围，利用/[0-9]/就能匹配所有的数字, /[a-z]/则可以匹配所有的英文小写字母。
即便有了集合和区间的定义方式，如果要同时匹配多个字符也还是要一一列举，这是低效的。所以在正则表达式里衍生了一批用来同时匹配多个字符的简便正则表达式
   匹配区间 正则表达式     除了换行符之外的任何字符 .</description>
    </item>
    
    <item>
      <title>JavaScript-异步解决方案</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>概念 Javascript语言的执行环境是&amp;quot;单线程&amp;quot;。也就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务。
这种模式虽然实现起来比较简单，执行环境相对单纯，但是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。
为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步和异步
同步 所有的任务都处在同一队列中，不可以插队，一个任务执行完接着开始执行下一个，相对于浏览器而言，同步的效率过低
异步 将一个任务放入到异步队列中，当这个任务执行完成之后，再从异步队列中提取出来，插队到同步队列中，拿到异步任务的结果，可以提升代码执行的效率，不需要因为一个耗时长的代码而一直等待
回调函数 ajax(url, () =&amp;gt; { // 处理逻辑 }) 假设多个请求存在依赖性，可能就会写出如下代码：
ajax(url, () =&amp;gt; { // 处理逻辑  ajax(url1, () =&amp;gt; { // 处理逻辑  ajax(url2, () =&amp;gt; { // 处理逻辑  }) }) }) 优点：解决了同步的问题
缺点：回调地狱，不能用 try catch 捕获错误，不能 return
事件监听 这种方式下，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生
下面是两个函数f1和f2，编程的意图是f2必须等到f1执行完成，才能执行
f1方法执行完，通过$emit发送一个事件doSomething（vue写法）
f1(){ // ...  // 发送事件  this.$emit(&amp;#39;doSomething&amp;#39;, {data:&amp;#39;data&amp;#39;}) } 通过$on接收事件
// 接收事件 this.$on(doSomething, (res) =&amp;gt; { if (res) { this.</description>
    </item>
    
    <item>
      <title>JavaScript-this指向</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-this%E6%8C%87%E5%90%91/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-this%E6%8C%87%E5%90%91/</guid>
      <description>this的指向  在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象
 看几个简单的例子:this指向
改变this的指向 var name = &amp;#34;windowsName&amp;#34;; var a = { name : &amp;#34;Cherry&amp;#34;, func1: function () { console.log(this.name) }, func2: function () { setTimeout( function () { this.func1() },100) } } a.func2() // this.func1 is not a function 在不使用箭头函数的情况下，是会报错的，因为最后调用setTimeout的对象是 window，但是在 window 中并没有 func1 函数
我们在改变 this 指向这一节将把这个例子作为 demo 进行改造
箭头函数 先看箭头函数和普通函数的重要区别：
 1、没有自己的this、super、arguments和new.target绑定
2、不能使用new来调用
3、没有原型对象
4、不可以改变this的绑定
5、形参名称不能重复
 箭头函数的 this 始终指向函数定义时的 this，而非执行时，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”</description>
    </item>
    
    <item>
      <title>JavaScript-EventLoop事件循环</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid>
      <description>概念 JavaScript 是一门单线程语言，即同一时间只能执行一个任务，即代码执行是同步并且阻塞的
 举例：这就像只有一个窗口的银行，客户需要一个一个排队办理业务
 只能同步执行肯定是有问题的，所以 JS 有了一个用来实现异步的函数：setTimeout
Event Loop 就是为了确保 异步代码 可以在 同步代码 执行后继续执行的
队列（Queue） 队列是一种FIFO(First In, First Out) 的数据结构，它的特点就是先进先出
 举例：生活中最常见的例子就是排队，排在队伍最前面的人最先被提供服务
 栈（Stack） 栈是一种 LIFO（Last In, First Out）的数据结构，特点即后进先出
 样例：大家都吃过桶装薯片吧~薯片在包装的时候只能从顶部放入，而吃的时候也只能从顶部拿出，这就叫后进先出
 调用栈（Call Stack） 调用栈本质上当然还是个栈，关键在于它里面装的东西，是一个个待执行的函数
Event Loop 会一直检查 Call Stack 中是否有函数需要执行，如果有，就从栈顶依次执行。同时，如果执行的过程中发现其他函数，继续入栈然后执行
先拿两个函数来说：
 栈空 现在执行到一个函数A，函数A入栈 函数A 又调用了函数B，函数B入栈 函数B执行完后出栈 然后继续执行函数A，执行完后A也出栈 栈空  看一段代码：
const bar = () =&amp;gt; console.log(&amp;#39;bar&amp;#39;) const baz = () =&amp;gt; console.log(&amp;#39;baz&amp;#39;) const foo = () =&amp;gt; { console.</description>
    </item>
    
    <item>
      <title>JavaScript-事件冒泡、事件捕获和事件委托</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</guid>
      <description>事件流 事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题
&amp;lt;div id=&amp;#34;outer&amp;#34;&amp;gt; &amp;lt;p id=&amp;#34;inner&amp;#34;&amp;gt;Click me!&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; 上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？
为了解决这个问题微软和网景提出了两种几乎完全相反的概念
事件冒泡 概念 微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象
样例：事件冒泡 阻止事件冒泡 事件的对象有一个stopPropagation()方法可以阻止事件冒泡，我们只需要把上个例子中button的事件处理程序修改如下：
document.getElementById(&amp;#34;button&amp;#34;).addEventListener(&amp;#34;click&amp;#34;,function(event){ alert(&amp;#34;button&amp;#34;) event.stopPropagation() },false) 事件捕获 概念 网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素
样例：事件捕获 阻止事件捕获 但是我们可以使用DOM3级新增事件stopImmediatePropagation()方法来阻止事件捕获，另外此方法还可以阻止事件冒泡。应用如下
document.getElementById(&amp;#34;second&amp;#34;).addEventListener(&amp;#34;click&amp;#34;,function(event){ alert(&amp;#34;second&amp;#34;) event.stopImmediatePropagation() },true) 那么 stopImmediatePropagation() 和 stopPropagation()的区别在哪儿呢？
后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生
事件委托 在实际的开发当中，利用事件流的特性，我们可以使用一种叫做事件代理的方法
样例 &amp;lt;ul class=&amp;#34;color_list&amp;#34;&amp;gt; &amp;lt;li&amp;gt;red&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;orange&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;yellow&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;green&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;blue&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;purple&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;div class=&amp;#34;box&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; .color_list{ display: flex; display: -webkit-flex; } .color_list li{ width: 100px; height: 100px; list-style: none; text-align: center; line-height: 100px; } //每个li加上对应的颜色，此处省略 .</description>
    </item>
    
    <item>
      <title>CSS-重绘、回流</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css-%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css-%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/</guid>
      <description>浏览器渲染 浏览器在渲染页面的时候，大致是以下几个步骤：
 解析html生成DOM树，解析css，生成CSSOM树，将DOM树和CSSOM树结合，生成渲染树； 根据渲染树，浏览器可以计算出网页中有哪些节点，各节点的CSS以及从属关系 - 【回流】 根据渲染树以及回流得到的节点信息，计算出每个节点在屏幕中的位置 - 【重绘】 最后将得到的节点位置信息交给浏览器的图形处理程序，让浏览器中显示页面  回流 概念 英文叫reflow，指的是当渲染树中的节点信息发生了大小、边距等问题，需要重新计算各节点和css具体的大小和位置
例：在css中对一个div修饰的样式中，使用了宽度50%，此时需要将50%转换为具体的像素，这个计算的过程，就是回流的过程
容易造成回流的操作 1、布局流相关操作  盒模型的相关操作会触发重新布局 定位相关操作会触发重新布局 浮动相关操作会触发重新布局  2、改变节点内的内容 改变节点的结构或其中的文本结构会触发重新布局
3、css  width height padding border margin position top left bottom right float clear text-align vertical-align line-height font-weight font-size font-family overflow white-space  重绘 概念 重绘：英文叫repaint，当节点的部分属性发生变化，但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程，就叫重绘
例：改变元素的背景颜色、字体颜色等操作会造成重绘
容易造成重绘操作的CSS  color border-style border-radius text-decoration box-shadow outline background  优化机制 1、浏览器优化 每次回流都会对浏览器造成额外的计算消耗，所以浏览器对于回流和重绘有一定的优化机制
浏览器通常都会将多次回流操作放入一个队列中，等过了一段时间或操作达到了一定的临界值，然后才会挨个执行，这样能节省一些计算消耗。
但是在获取布局信息操作的时候，会强制将队列清空，也就是强制回流，比如访问或操作以下或方法时：
 offsetTop offsetLeft offsetWidth offsetHeight scrollTop scrollLeft scrollWidth scrollHeight clientTop clientLeft clientWidth clientHeight getComputedStyle()  这些属性或方法都需要得到最新的布局信息，所以浏览器必须去回流执行。因此，在项目中，尽量避免使用上述属性或方法，如果非要使用的时候，也尽量将值缓存起来，而不是一直获取</description>
    </item>
    
    <item>
      <title>Vue2-token</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-token/</link>
      <pubDate>Fri, 06 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-token/</guid>
      <description>token的含义  1、Token的引入： Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。
2、Token的定义： Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。
3、使用Token的目的： Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。
4、Token 的优点： 扩展性更强，也更安全点，非常适合用在 Web 应用或者移动应用上。Token 的中文有人翻译成 “令牌”，我觉得挺好，意思就是，你拿着这个令牌，才能过一些关卡。
 项目中使用token 说明
   文件名称 功能描述     auth.js 设置、获取以及清空cookie   http.js 接口请求封装   store.js 对接业务的状态管理，负责登录、登出状态的保存和移除    流程梳理
  用户输入信息点击登录，调用store.js中的Login方法请求登录接口，调用成功返回200回传token值
  接着调用SaveLoginInfo方法，将token值state中保存一份，再调用setToken将token在cookie中也保存一份
因为vuex刷新页面数据会丢，所以在cookie里面也放了一份，使用的时候只需要通过getter方法获取state就可以，state默认值为调用getToken获取的cookie中的token值
  此时token对象就可以全局使用了，除登录以外的所有接口请求都要传token，否则会报505错误
  token由服务端生成，设置了失效时间为24小时
当token过期，前端再发送请求，服务端会返回505，此响应会被http.js的拦截器捕获
捕获后先弹框提示‘登录信息已过期，请重新登录&#39;，接着调用store.js中的ClearLoginInfo方法清空state中全局token，再调用removeToken移除cookie
  清空完之后会执行跳转，重新回到登录页面重复步骤一
  退出登录与登录操作类似，用户点击退出登录按钮，调用store.js里的ClearLoginInfo方法。先清空state中全局token，再调用removeToken移除cookie
  代码
auth.js
import Cookies from &amp;#39;js-cookie&amp;#39; const TokenKey = &amp;#39;sxmanage-auth-token&amp;#39;// tokenKey为固定字符串  // 根据TokenKey获取cookie中的token信息 export function getToken () { return Cookies.</description>
    </item>
    
    <item>
      <title>JavaScript-跨域</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Wed, 04 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E8%B7%A8%E5%9F%9F/</guid>
      <description>概述 含义 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策
最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页&amp;quot;同源&amp;quot;
所谓&amp;quot;同源&amp;quot;指的是&amp;quot;三个相同&amp;quot;
  协议相同 域名相同 端口相同   常见跨域场景
目的 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。
设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？
很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制
由此可见，&amp;ldquo;同源政策&amp;quot;是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了
限制范围   Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送   解决方案 CORS CORS 即是指跨域资源共享。它允许浏览器向非同源服务器，发出 Ajax 请求，从而克服了 Ajax 只能同源使用的限制。这种方式的跨域主要是在后端进行设置
这种方式的关键是后端进行设置，即是后端开启 Access-Control-Allow-Origin 为*或对应的origin就可以实现跨域
cors.html
let xhr = new XMLHttpRequest() xhr.open(&amp;#39;GET&amp;#39;, &amp;#39;http://localhost:8002/request&amp;#39;) xhr.send(null) server.js
const express = require(&amp;#39;express&amp;#39;) const app = express() app.use((req, res, next) =&amp;gt; { res.</description>
    </item>
    
    <item>
      <title>【待补充】CSS-Less、Sass</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css-lesssass/</link>
      <pubDate>Wed, 04 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css-lesssass/</guid>
      <description></description>
    </item>
    
    <item>
      <title>【待补充】CSS3-响应式布局</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css3-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</link>
      <pubDate>Wed, 04 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css3-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Demo-CSS</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/demo-css/</link>
      <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/demo-css/</guid>
      <description>  border拼接   </description>
    </item>
    
    <item>
      <title>Demo-Vue</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/demo-vue/</link>
      <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/demo-vue/</guid>
      <description>  规范   组件 -Element-UI表单   路由 -Vue-Demo-路由   状态、缓存 -Vue-Demo-状态、缓存   方法封装 -axios封装Http工具类   数据字典   自定义指令 -防抖 -节流   CSS   第三方插件   打包   </description>
    </item>
    
    <item>
      <title>Demo-JavaScript</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/demo-javascript/</link>
      <pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/demo-javascript/</guid>
      <description>  日期、时间 -日期格式化 -日期计算 -获取当前日期00:00:00到23:59:59   校验 -身份证校验 -邮箱校验 -电话校验   字符串   数字 -数字转汉字大写   数组 -数组去重 -计算数组重复元素 -深拷贝   算法   </description>
    </item>
    
    <item>
      <title>CSS3-动画</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css3-%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/css3-%E5%8A%A8%E7%94%BB/</guid>
      <description>一、素转换transform 1.元素位置移动translate() 参数：左(X轴)，顶部(Y轴)单位px
样例：元素位置移动
2.元素旋转rotate() 参数：旋转度数(负值是允许的，这样是元素逆时针旋转)，单位deg
样例：元素旋转
3.元素缩放scale() 参数：宽度缩放倍数、高度缩放倍数无参数
样例：元素缩放
4.元素倾斜skew() 通过设置倾斜将正方形转化成菱形
参数：X轴，Y轴单位deg
样例：元素倾斜
5.元素转换matrix() 方法：将上面的方法合并成一个，matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能
二、过渡transition 属性：
  transition-property：规定应用过渡的 CSS 属性的名称
  transition-duration：定义过渡效果花费的时间。默认是 0
  transition-timing-function：规定过渡效果的时间曲线。默认是 &amp;ldquo;ease&amp;rdquo;
 linear：规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)） ease：规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)） ease-in：规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)） ease-out：规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)） ease-in-out：规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n)：在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值    transition-delay：规定过渡效果何时开始。默认是 0
  样例：blog - CSS3动画 - 过渡
三、动画animation 属性：
 @keyframes：声明动画 animation-name：引入动画 animation-duration： 规定动画完成一个周期所花费的秒或毫秒。默认是 0，单位s animation-timing-function：规定动画的速度曲线。默认是 &amp;ldquo;ease&amp;rdquo;，设置同上 animation-fill-mode：规定当动画不播放时，要应用到元素的样式。 animation-delay：规定动画何时开始。默认是 0，单位s animation-iteration-count：规定动画被播放的次数。  填写一个数字，默认是 1 infinite指定动画应该播放无限次   animation-direction：规定动画是否在下一周期逆向地播放，默认是 &amp;ldquo;normal&amp;rdquo;  normal：默认值。动画按正常播放 reverse：动画反向播放 alternate：动画在奇数次（1、3、5&amp;hellip;）正向播放，在偶数次（2、4、6&amp;hellip;）反向播放 reverse：动画在奇数次（1、3、5&amp;hellip;）反向播放，在偶数次（2、4、6&amp;hellip;）正向播放 initial：设置该属性为它的默认值 inherit：从父元素继承该属性   animation-play-state：规定动画是否正在运行或暂停，默认是 &amp;ldquo;running&amp;rdquo;  paused：指定暂停动画 running：指定正在运行的动画    样例：blog - CSS3动画 - 动画</description>
    </item>
    
    <item>
      <title>JavaScript-防抖、节流</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</link>
      <pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</guid>
      <description>防抖 概念 任务频繁触发的情况下，只有任务触发的间隔超过制定的时间间隔的时候，任务才会被执行
将一段时间内连续的多次触发转化为一次触发。
应用场景   用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询ajax请求，这样可以有效减少请求次数，节约请求资源；
  window的resize、scroll事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次；
  实例   非立即执行版 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;ie=edge&amp;#34;&amp;gt; &amp;lt;title&amp;gt;防抖&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button id=&amp;#34;debounce&amp;#34;&amp;gt;点我防抖！&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; window.onload = function() { // 1、获取这个按钮，并绑定事件  var myDebounce = document.getElementById(&amp;#34;debounce&amp;#34;); myDebounce.addEventListener(&amp;#34;click&amp;#34;, debounce(sayDebounce)); } // 2、防抖功能函数，接受传参  function debounce(fn) { // 4、创建一个标记用来存放定时器的返回值  let timeout = null; return function() { // 5、每次当用户点击/输入的时候，把前一个定时器清除  clearTimeout(timeout); // 6、然后创建一个新的 setTimeout，  // 这样就能保证点击按钮后的 interval 间隔内  // 如果用户还点击了的话，就不会执行 fn 函数  timeout = setTimeout(() =&amp;gt; { fn.</description>
    </item>
    
    <item>
      <title>Vue3-Teleport</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-teleport/</link>
      <pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-teleport/</guid>
      <description>概念  Teleport 是一种能够将我们的模板移动到 DOM中Vue app之外的其他位置的技术，就有点像哆啦A梦的“任意门”
场景：像 modals,toast 等这样的元素，很多情况下，我们将它完全的和我们的 Vue 应用的 DOM完全剥离，管理起来反而会方便容易很多
原因在于如果我们嵌套在Vue的某个组件内部，那么处理嵌套组件的定位、z-index和样式就会变得很困难
另外，像 modals，toast等这样的元素需要使用到 Vue组件的状态（data或者props）的值
这就是Teleport派上用场的地方。我们可以在组件的逻辑位置写模板代码，这意味着我们可以使用组件的data或props。然后在Vue应用的范围之外渲染它
 Teleport 的使用 index.html中
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;teleport-target&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;module&amp;#34; src=&amp;#34;/src/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; src/components/HelloWorld.vue中，添加如下，留意to属性跟上面的id选择器一致
&amp;lt;button @click=&amp;#34;showToast&amp;#34; class=&amp;#34;btn&amp;#34;&amp;gt;打开 toast&amp;lt;/button&amp;gt; &amp;lt;!-- to 属性就是目标位置 --&amp;gt; &amp;lt;teleport to=&amp;#34;#teleport-target&amp;#34;&amp;gt; &amp;lt;div v-if=&amp;#34;visible&amp;#34; class=&amp;#34;toast-wrap&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;toast-msg&amp;#34;&amp;gt;我是一个 Toast 文案&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/teleport&amp;gt; import { ref } from &amp;#39;vue&amp;#39;; export default { setup() { // toast 的封装  const visible = ref(false); let timer; const showToast = () =&amp;gt; { visible.</description>
    </item>
    
    <item>
      <title>Vue3-组合式API</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-%E7%BB%84%E5%90%88%E5%BC%8Fapi/</link>
      <pubDate>Mon, 05 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-%E7%BB%84%E5%90%88%E5%BC%8Fapi/</guid>
      <description>概念  通过创建 Vue 组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而随着项目的扩大，功能越来越复杂，定义的数据以及对其数据的操作被放在不同的地方，如methods，watch，碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块，于是出现了组合式api
 组合式api主要解决的问题就是单业务逻辑代码单文件处理，将一个巨大无比的组件分成无数小的文件模块每个模块只处理很少的业务，通过定义setUp选项，将单逻辑的变量、生命周期以及方法独立成JS，再通过export的方式将需要使用的暴漏出来。Vue3提供的响应式API基本上可以保证我们在JS中实现响应式变量、父子组件传值、生命周期等所有操作，这是其它方式所不具备的
为什么要使用组合式 API   组件化的缺点 使用 (data、computed、methods、watch) 组件选项来组织逻辑通常都很有效。然而，当我们的组件开始变得更大时，逻辑关注点的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解
这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块
  提取公共JS方式的缺点 因为无法获取vue对象，只能编写非业务代码，例如工具方法
  插槽的缺点  配置最终出现在模板中，理想情况下，模板应仅包含我们要呈现的内容 公开的属性仅在模板中可用    mixin方式的缺点 mixin的解决方案是将vue页面的js部分提取成公共的以供多个相似模块的共用。这种方式的缺点主要由以下几点
 如methods,components等，选项会被合并，键冲突的组件会覆盖混入对象的，比如混入对象里有个方法A，组件里也有方法A，这时候在组件里调用的话，执行的是组件里的A方法 不可知，不易维护因为你可以在mixins里几乎可以加任何代码，props、data、methods、各种东西，就导致如果不了解mixins封装的代码的话，是很难维护的    样例 说明 实现了一个简单的列表功能，包括：列表展示、查看更多、关键字搜索
   文件名称 功能描述     app.vue 主页，引入列表和搜索组件   app.js 主页面逻辑，包含：1、初始化列表2、加载更多（接收子组件事件）3、关键字搜索（接收子组件事件）   panel.vue 列表组件：接收列表数据渲染数据   panel.js 列表组件逻辑：1、加载更多（emit发送事件）   search.vue 搜索组件：点击搜索框切换选中样式，输入关键字刷新列表数据   search.js 搜索组件逻辑：1、点击搜索框样式切换，自动聚集2、搜索值监听(emit发送事件)    代码 app.</description>
    </item>
    
    <item>
      <title>Vue2-nextTick</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-nexttick/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-nexttick/</guid>
      <description>概念  官方文档说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
 异步解析  Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新
 ​	简而言之，异步接信息的运行机制如下
 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack） 主线程之外，还存在一个&amp;quot;任务队列&amp;quot;（task queue）。只要异步任务有了运行结果，就在&amp;quot;任务队列&amp;quot;之中放置一个事件 一旦&amp;quot;执行栈&amp;quot;中的所有同步任务执行完毕，系统就会读取&amp;quot;任务队列&amp;quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行 主线程不断重复上面的第三步  事件循环说明 简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新
//改变数据 vm.message = &amp;#39;changed&amp;#39; //想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新 console.log(vm.$el.textContent) // 并不会得到&amp;#39;changed&amp;#39;  //这样可以，nextTick里面的代码会在DOM更新后执行 Vue.nextTick(function(){ console.log(vm.$el.textContent) // 可以得到&amp;#39;changed&amp;#39; })   本次更新循环
 首先修改数据，这是同步任务。同一事件循环的所有同步任务都在主线程上执行，形成一个执行栈，此时还未涉及DOM Vue开启一个异步队列，并缓冲再次事件循环中发生的所有数据改变。如果同一个watcher被多次执行，只会被推入到队列中一次    下次更新循环
 同步任务执行完毕，开始执行异步watcher队列的任务，更新DOM。Vue在内部尝试对异步队列使用原生的Promise.then和messageChannel方法，如果执行环境不支持，会采用setTimeOut(fn,0)代替    下次更新循环结束之后
此时通过Vue.nextTick获取到改变后的DOM。通过setTimeOut(fn,0)也可以同样获取到
  简单总结事件循环：
 同步代码执行 查找异步队列，推入执行栈，执行Vue.nextTick[事件1] 查找异步队列，推入执行栈，执行Vue.nextTick[事件2]  总之，异步是单独的一个tick，不会和同步在同一个tick里发生，也是DOM不会马上改变的原因</description>
    </item>
    
    <item>
      <title>Vue2-刷新组件</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6/</guid>
      <description>刷新组件 provide、inject 结合 v-if 这对选项需要一起使用，以允许一个根组件向其所有子组件注入一个依赖，实现原理就是通过控制router-view 的显示与隐藏，来重渲染路由区域，重而达到页面刷新的效果，show -&amp;gt; false -&amp;gt; show
  修改app.vue，利用 v-if 可以刷新页面的属性，同时使用 provide 和 inject 将祖先节点的数据传递给子代节点
&amp;lt;template&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;router-view v-if=&amp;#34;isRouterAlive&amp;#34;&amp;gt;&amp;lt;/router-view&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { name: &amp;#39;App&amp;#39;, provide (){ return { reload:this.reload } }, data(){ return { isRouterAlive:true } }, methods:{ reload (){ this.isRouterAlive = false this.$nextTick(function(){ this.isRouterAlive = true }) } } } &amp;lt;/script&amp;gt;   在要刷新的子路由页面引入inject,然后执行reload事件即可刷新页面
export default { inject:[&amp;#39;reload&amp;#39;], data() { return {} }, methods: { reflesh(){ this.</description>
    </item>
    
    <item>
      <title>JavaScript-原型链</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <description>原型   理解原型对象 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。
使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中
function Person() {} Person.prototype.name = &amp;#39;Nicholas&amp;#39; Person.prototype.age = 19 Person.prototype.sayName = function () { console.log(this.name) } let person1 = new Person() person1.sayName() // 输出：Nicholas  let person2 = new Person() person2.sayName() // 输出：Nicholas  console.log(person1.sayName == person2.sayName) // 输出：true 我们将sayName()方法和所有属性直接添加到Person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName()函数
创建了自定义构造函数之后，其原型对象默认只会取得constructor属性，至于其它方法，则都是从Object继承而来。当调用构造函数创建一个新实例后，该实例内部将包含一个指针（内部属性）____proto____指向构造函数的原型对象，需要明确的是，这个连接存在与实例和构造函数的原型之间，而不是存在与实例与构造函数之间
上图展示了Person构造函数、Person的原型属性以及Person现有两个实例之间的关系。在此，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其它属性。Person的每个实例person1和person2都包含一个内部属性____proto____，该属性仅仅指向了Person.prototype，换句话说，它们与构造函数没有直接关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName。这是通过查找对象属性的过程来实现的
  原型搜索机制 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象的实例本身开始。如果在实例中找到了具有给定名字的实现，则返回该属性的值，如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person.sayName()的时候，会先后执行两次搜索。首先，解析器会问：&amp;ldquo;实例person1有sayName属性吗？&amp;ldquo;答：&amp;ldquo;没有。&amp;ldquo;然后，它继续搜索，再问：&amp;ldquo;person1的原型有sayName属性吗？&amp;ldquo;答：&amp;ldquo;有。&amp;ldquo;于是，他就读取那个保存在原型对象中的函数。当我们调用person2.sayName()时，将会重现相同的搜索过程，得到相同的结果。而正是多个对象实例共享原型所保存的属性和方法的基本原理
  注意事项 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性
function Person() {} Person.prototype.name = &amp;#39;Nicholas&amp;#39; Person.prototype.age = 19 Person.prototype.sayName = function () { console.</description>
    </item>
    
    <item>
      <title>JavaScript-闭包</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E9%97%AD%E5%8C%85/</link>
      <pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E9%97%AD%E5%8C%85/</guid>
      <description>概念   变量的作用域 要理解闭包，首先必须理解Javascript特殊的变量作用域
变量的作用域无非就是两种：全局变量和局部变量
Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量
var n=999 function f1(){ alert(n) } f1() // 999 在函数外部无法读取函数内的局部变量
function f1(){ var n=999 } alert(n); // error   闭包的描述 闭包就是能够读取其他函数内部变量的函数
由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成&amp;quot;定义在一个函数内部的函数&amp;quot;
所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁，f2函数，就是闭包
function f1(){ var n=999 function f2(){ alert(n) } return f2 } var result = f1() result() // 999   闭包优缺点 优点：
  希望一个变量长期驻扎在内存中
  避免全局变量的污染
  私有成员的存在
  缺点：闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗
  应用场景   匿名自执行函数 我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包</description>
    </item>
    
    <item>
      <title>面试-2021年2月</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/%E9%9D%A2%E8%AF%95-2021%E5%B9%B42%E6%9C%88/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/%E9%9D%A2%E8%AF%95-2021%E5%B9%B42%E6%9C%88/</guid>
      <description>JavaScript   跨域 JavaScript-跨域
     get、post区别  get参数url可见，post参数url不可见 通过拼接url进行传递参数，post通过body体传递参数 get请求可以缓存，post请求不可以缓存 get请求页面后退时不产生影响、post请求页面后退时会重新提交请求 get一般传输数据大小不超过2k-4k，post请求传输数据的大小可配置       数据类型   单类型：String、Number、boolean、null、undefined
  引用类型：object、function、array、Date、RegExp
       值传递和引用传递   基本类型复制后两个变量完全独立，一方改变都不会影响另一方
  引用类型复制的时引用，之后的任何一方改变都会映射到另一方
       闭包 JavaScript-闭包
     箭头函数的好处   简洁
  不会改变this本来的绑定
       事件的冒泡和捕获 JavaScript-事件冒泡、事件捕获和事件委托</description>
    </item>
    
    <item>
      <title>GitHubPages&#43;Hugo构建个人博客</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/githubpages&#43;hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/githubpages&#43;hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>hugo配置 1、安装   下载地址：https://github.com/gohugoio/hugo/releases
  我使用的版本：  解压后即可使用hugo命令，不过只能在当前文件夹下使用，所以需要配置环境变量
  2、配置环境变量   在系统变量Path后面追加一条，为hugo.exe的解压地址我的在D盘
D:\hugo_0.83.1_Windows-64bit   3、项目创建   通过hugo命令创建站点目录并切换到该目录
hugo new site hugo-blog cd hugo-blog 目录结构如下，此时如果运行的话浏览器会白屏，因为此时只是一个空的站点需要下载主题后才能看到内容
  4、主题配置   主题网站：https://themes.gohugo.io/
  我用的是这个主题：https://github.com/AmazingRise/hugo-theme-diary
  选好主题一般都会直接指向GitHub仓库，下载zip到本地就行
  将下载好的主题解压移动到项目目录下的themes文件夹
  配置站点根目录下的config.toml文件
我用的主题里面有作者提供的实例网站配置，把里面的内容复制到站点根目录的config.toml就完美运行了
这里需要注意config.toml配置的theme名称必须和themes下的文件夹名称保持一致
具体hugo的配置还没仔细研究，本篇就简单介绍一下大体的搭建流程，以后可能会写一篇hugo配置/开发相关的
  5、本地预览   启动 Hugo 预览服务器，构建站点内容到内存中并在检测到文件更改后重新渲染
hugo server   6、内容发布   在站点目录下有一个content文件夹，在该文件夹下创建一个posts，posts下创建.md格式的文章就可以自动识别发布了
  同理图片静态资源需要放在站点根目录static下，内容中图片引用也是以static为根目录进行读取的</description>
    </item>
    
  </channel>
</rss>
