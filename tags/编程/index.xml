<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on DaMuWang</title>
    <link>https://damuwangs.github.io/tags/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on DaMuWang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 04 Aug 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://damuwangs.github.io/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JavaScript-跨域</title>
      <link>https://damuwangs.github.io/posts/javascript-%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Wed, 04 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/javascript-%E8%B7%A8%E5%9F%9F/</guid>
      <description>概述 含义 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策
最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页&amp;quot;同源&amp;rdquo;
所谓&amp;quot;同源&amp;quot;指的是&amp;quot;三个相同&amp;rdquo;
  协议相同 域名相同 端口相同   常见跨域场景
目的 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。
设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？
很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制
由此可见，&amp;ldquo;同源政策&amp;quot;是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了
限制范围   Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送   解决方案 CORS CORS 即是指跨域资源共享。它允许浏览器向非同源服务器，发出 Ajax 请求，从而克服了 Ajax 只能同源使用的限制。这种方式的跨域主要是在后端进行设置
这种方式的关键是后端进行设置，即是后端开启 Access-Control-Allow-Origin 为*或对应的origin就可以实现跨域
cors.html
let xhr = new XMLHttpRequest() xhr.open(&amp;#39;GET&amp;#39;, &amp;#39;http://localhost:8002/request&amp;#39;) xhr.send(null) server.js
const express = require(&amp;#39;express&amp;#39;) const app = express() app.use((req, res, next) =&amp;gt; { res.</description>
    </item>
    
    <item>
      <title>CSS-Demo</title>
      <link>https://damuwangs.github.io/posts/css-demo/</link>
      <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/css-demo/</guid>
      <description>  border拼接   </description>
    </item>
    
    <item>
      <title>Vue-Demo</title>
      <link>https://damuwangs.github.io/posts/vue-demo/</link>
      <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/vue-demo/</guid>
      <description>  组件 -Element-UI表单   自定义指令 -防抖 -节流   </description>
    </item>
    
    <item>
      <title>JavaScript-Demo</title>
      <link>https://damuwangs.github.io/posts/javascript-demo/</link>
      <pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/javascript-demo/</guid>
      <description>  日期、时间 -日期格式化 -日期计算   校验 -身份证校验 -邮箱校验 -电话校验   字符串   数字 -数字转汉字大写   数组 -数组去重 -计算数组重复元素 -深拷贝   算法   </description>
    </item>
    
    <item>
      <title>CSS3动画</title>
      <link>https://damuwangs.github.io/posts/css3%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/css3%E5%8A%A8%E7%94%BB/</guid>
      <description>一、素转换transform 1.元素位置移动translate() 参数：左(X轴)，顶部(Y轴)单位px
样例：元素位置移动
2.元素旋转rotate() 参数：旋转度数(负值是允许的，这样是元素逆时针旋转)，单位deg
样例：元素旋转
3.元素缩放scale() 参数：宽度缩放倍数、高度缩放倍数无参数
样例：元素缩放
4.元素倾斜skew() 通过设置倾斜将正方形转化成菱形
参数：X轴，Y轴单位deg
样例：元素倾斜
5.元素转换matrix() 方法：将上面的方法合并成一个，matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能
二、过渡transition 属性：
  transition-property：规定应用过渡的 CSS 属性的名称
  transition-duration：定义过渡效果花费的时间。默认是 0
  transition-timing-function：规定过渡效果的时间曲线。默认是 &amp;ldquo;ease&amp;rdquo;
 linear：规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)） ease：规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)） ease-in：规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)） ease-out：规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)） ease-in-out：规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n)：在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值    transition-delay：规定过渡效果何时开始。默认是 0
  样例：blog - CSS3动画 - 过渡
三、动画animation 属性：
 @keyframes：声明动画 animation-name：引入动画 animation-duration： 规定动画完成一个周期所花费的秒或毫秒。默认是 0，单位s animation-timing-function：规定动画的速度曲线。默认是 &amp;ldquo;ease&amp;rdquo;，设置同上 animation-fill-mode：规定当动画不播放时，要应用到元素的样式。 animation-delay：规定动画何时开始。默认是 0，单位s animation-iteration-count：规定动画被播放的次数。  填写一个数字，默认是 1 infinite指定动画应该播放无限次   animation-direction：规定动画是否在下一周期逆向地播放，默认是 &amp;ldquo;normal&amp;rdquo;  normal：默认值。动画按正常播放 reverse：动画反向播放 alternate：动画在奇数次（1、3、5&amp;hellip;）正向播放，在偶数次（2、4、6&amp;hellip;）反向播放 reverse：动画在奇数次（1、3、5&amp;hellip;）反向播放，在偶数次（2、4、6&amp;hellip;）正向播放 initial：设置该属性为它的默认值 inherit：从父元素继承该属性   animation-play-state：规定动画是否正在运行或暂停，默认是 &amp;ldquo;running&amp;rdquo;  paused：指定暂停动画 running：指定正在运行的动画    样例：blog - CSS3动画 - 动画</description>
    </item>
    
    <item>
      <title>JavaScript-防抖、节流</title>
      <link>https://damuwangs.github.io/posts/javascript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</link>
      <pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/javascript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</guid>
      <description>防抖 概念 任务频繁触发的情况下，只有任务触发的间隔超过制定的时间间隔的时候，任务才会被执行
将一段时间内连续的多次触发转化为一次触发。
应用场景   用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询ajax请求，这样可以有效减少请求次数，节约请求资源；
  window的resize、scroll事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次；
  实例   非立即执行版 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;ie=edge&amp;#34;&amp;gt; &amp;lt;title&amp;gt;防抖&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button id=&amp;#34;debounce&amp;#34;&amp;gt;点我防抖！&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; window.onload = function() { // 1、获取这个按钮，并绑定事件  var myDebounce = document.getElementById(&amp;#34;debounce&amp;#34;); myDebounce.addEventListener(&amp;#34;click&amp;#34;, debounce(sayDebounce)); } // 2、防抖功能函数，接受传参  function debounce(fn) { // 4、创建一个标记用来存放定时器的返回值  let timeout = null; return function() { // 5、每次当用户点击/输入的时候，把前一个定时器清除  clearTimeout(timeout); // 6、然后创建一个新的 setTimeout，  // 这样就能保证点击按钮后的 interval 间隔内  // 如果用户还点击了的话，就不会执行 fn 函数  timeout = setTimeout(() =&amp;gt; { fn.</description>
    </item>
    
    <item>
      <title>Vue3-Teleport</title>
      <link>https://damuwangs.github.io/posts/vue3-teleport/</link>
      <pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/vue3-teleport/</guid>
      <description>概念  Teleport 是一种能够将我们的模板移动到 DOM中Vue app之外的其他位置的技术，就有点像哆啦A梦的“任意门”
场景：像 modals,toast 等这样的元素，很多情况下，我们将它完全的和我们的 Vue 应用的 DOM完全剥离，管理起来反而会方便容易很多
原因在于如果我们嵌套在Vue的某个组件内部，那么处理嵌套组件的定位、z-index和样式就会变得很困难
另外，像 modals，toast等这样的元素需要使用到 Vue组件的状态（data或者props）的值
这就是Teleport派上用场的地方。我们可以在组件的逻辑位置写模板代码，这意味着我们可以使用组件的data或props。然后在Vue应用的范围之外渲染它
 Teleport 的使用 index.html中
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;teleport-target&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;module&amp;#34; src=&amp;#34;/src/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; src/components/HelloWorld.vue中，添加如下，留意to属性跟上面的id选择器一致
&amp;lt;button @click=&amp;#34;showToast&amp;#34; class=&amp;#34;btn&amp;#34;&amp;gt;打开 toast&amp;lt;/button&amp;gt; &amp;lt;!-- to 属性就是目标位置 --&amp;gt; &amp;lt;teleport to=&amp;#34;#teleport-target&amp;#34;&amp;gt; &amp;lt;div v-if=&amp;#34;visible&amp;#34; class=&amp;#34;toast-wrap&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;toast-msg&amp;#34;&amp;gt;我是一个 Toast 文案&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/teleport&amp;gt; import { ref } from &amp;#39;vue&amp;#39;; export default { setup() { // toast 的封装  const visible = ref(false); let timer; const showToast = () =&amp;gt; { visible.</description>
    </item>
    
    <item>
      <title>Vue3-组合式API</title>
      <link>https://damuwangs.github.io/posts/vue3-%E7%BB%84%E5%90%88%E5%BC%8Fapi/</link>
      <pubDate>Mon, 05 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/vue3-%E7%BB%84%E5%90%88%E5%BC%8Fapi/</guid>
      <description>概念  通过创建 Vue 组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而随着项目的扩大，功能越来越复杂，定义的数据以及对其数据的操作被放在不同的地方，如methods，watch，碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块，于是出现了组合式api
 组合式api主要解决的问题就是单业务逻辑代码单文件处理，将一个巨大无比的组件分成无数小的文件模块每个模块只处理很少的业务，通过定义setUp选项，将单逻辑的变量、生命周期以及方法独立成JS，再通过export的方式将需要使用的暴漏出来。Vue3提供的响应式API基本上可以保证我们在JS中实现响应式变量、父子组件传值、生命周期等所有操作，这是其它方式所不具备的
为什么要使用组合式 API   组件化的缺点 使用 (data、computed、methods、watch) 组件选项来组织逻辑通常都很有效。然而，当我们的组件开始变得更大时，逻辑关注点的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解
这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块
  提取公共JS方式的缺点 因为无法获取vue对象，只能编写非业务代码，例如工具方法
  插槽的缺点  配置最终出现在模板中，理想情况下，模板应仅包含我们要呈现的内容 公开的属性仅在模板中可用    mixin方式的缺点 mixin的解决方案是将vue页面的js部分提取成公共的以供多个相似模块的共用。这种方式的缺点主要由以下几点
 如methods,components等，选项会被合并，键冲突的组件会覆盖混入对象的，比如混入对象里有个方法A，组件里也有方法A，这时候在组件里调用的话，执行的是组件里的A方法 不可知，不易维护因为你可以在mixins里几乎可以加任何代码，props、data、methods、各种东西，就导致如果不了解mixins封装的代码的话，是很难维护的    样例 说明 实现了一个简单的列表功能，包括：列表展示、查看更多、关键字搜索
   文件名称 功能描述     app.vue 主页，引入列表和搜索组件   app.js 主页面逻辑，包含：1、初始化列表2、加载更多（接收子组件事件）3、关键字搜索（接收子组件事件）   panel.vue 列表组件：接收列表数据渲染数据   panel.js 列表组件逻辑：1、加载更多（emit发送事件）   search.vue 搜索组件：点击搜索框切换选中样式，输入关键字刷新列表数据   search.js 搜索组件逻辑：1、点击搜索框样式切换，自动聚集2、搜索值监听(emit发送事件)    代码 app.</description>
    </item>
    
    <item>
      <title>Vue2-nextTick</title>
      <link>https://damuwangs.github.io/posts/vue2-nexttick/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/vue2-nexttick/</guid>
      <description>概念  官方文档说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
 异步解析  Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新
 ​	简而言之，异步接信息的运行机制如下
 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack） 主线程之外，还存在一个&amp;quot;任务队列&amp;rdquo;（task queue）。只要异步任务有了运行结果，就在&amp;quot;任务队列&amp;quot;之中放置一个事件 一旦&amp;quot;执行栈&amp;quot;中的所有同步任务执行完毕，系统就会读取&amp;quot;任务队列&amp;rdquo;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行 主线程不断重复上面的第三步  事件循环说明 简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新
//改变数据 vm.message = &amp;#39;changed&amp;#39; //想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新 console.log(vm.$el.textContent) // 并不会得到&amp;#39;changed&amp;#39;  //这样可以，nextTick里面的代码会在DOM更新后执行 Vue.nextTick(function(){ console.log(vm.$el.textContent) // 可以得到&amp;#39;changed&amp;#39; })   本次更新循环
 首先修改数据，这是同步任务。同一事件循环的所有同步任务都在主线程上执行，形成一个执行栈，此时还未设计DOM Vue开启一个异步队列，并缓冲再次事件循环中发生的所有数据改变。如果同一个watcher被多次执行，只会被推入到队列中一次    下次更新循环
 同步任务执行完毕，开始执行异步watcher队列的任务，更新DOM。Vue在内部尝试对异步队列使用原生的Promise.then和messageChannel方法，如果执行环境不支持，会采用setTimeOut(fn,0)代替    下次更新循环结束之后
此时通过Vue.nextTick获取到改变后的DOM。通过setTimeOut(fn,0)也可以同样获取到
  简单总结事件循环：
 同步代码执行 查找异步队列，推入执行栈，执行Vue.nextTick[事件1] 查找异步队列，推入执行栈，执行Vue.nextTick[事件2]  总之，异步是单独的一个tick，不会和同步在同一个tick里发生，也是DOM不会马上改变的原有</description>
    </item>
    
    <item>
      <title>Vue2-刷新组件</title>
      <link>https://damuwangs.github.io/posts/vue2-%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/vue2-%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6/</guid>
      <description>刷新组件 provide、inject 结合 v-if 这对选项需要一起使用，以允许一个根组件向其所有子组件注入一个依赖，实现原理就是通过控制router-view 的显示与隐藏，来重渲染路由区域，重而达到页面刷新的效果，show -&amp;gt; false -&amp;gt; show
  修改app.vue，利用 v-if 可以刷新页面的属性，同时使用 provide 和 inject 将祖先节点的数据传递给子代节点
&amp;lt;template&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;router-view v-if=&amp;#34;isRouterAlive&amp;#34;&amp;gt;&amp;lt;/router-view&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { name: &amp;#39;App&amp;#39;, provide (){ return { reload:this.reload } }, data(){ return { isRouterAlive:true } }, methods:{ reload (){ this.isRouterAlive = false this.$nextTick(function(){ this.isRouterAlive = true }) } } } &amp;lt;/script&amp;gt;   在要刷新的子路由页面引入inject,然后执行reload事件即可刷新页面
export default { inject:[&amp;#39;reload&amp;#39;], data() { return {} }, methods: { reflesh(){ this.</description>
    </item>
    
    <item>
      <title>JavaScript-原型链</title>
      <link>https://damuwangs.github.io/posts/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <description>原型   理解原型对象 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。
使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中
function Person() {} Person.prototype.name = &amp;#39;Nicholas&amp;#39; Person.prototype.age = 19 Person.prototype.sayName = function () { console.log(this.name) } let person1 = new Person() person1.sayName() // 输出：Nicholas  let person2 = new Person() person2.sayName() // 输出：Nicholas  console.log(person1.sayName == person2.sayName) // 输出：true 我们将sayName()方法和所有属性直接添加到Person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName()函数
创建了自定义构造函数之后，其原型对象默认只会取得constructor属性，至于其它方法，则都是从Object继承而来。当调用构造函数创建一个新实例后，该实例内部将包含一个指针（内部属性）____proto____指向构造函数的原型对象，需要明确的是，这个连接存在与实例和构造函数的原型之间，而不是存在与实例与构造函数之间
上图展示了Person构造函数、Person的原型属性以及Person现有两个实例之间的关系。在此，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其它属性。Person的每个实例person1和person2都包含一个内部属性____proto____，该属性仅仅指向了Person.prototype，换句话说，它们与构造函数没有直接关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName。这是通过查找对象属性的过程来实现的
  原型搜索机制 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象的实例本身开始。如果在实例中找到了具有给定名字的实现，则返回该属性的值，如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person.sayName()的时候，会先后执行两次搜索。首先，解析器会问：&amp;ldquo;实例person1有sayName属性吗？&amp;ldquo;答：&amp;ldquo;没有。&amp;ldquo;然后，它继续搜索，再问：&amp;ldquo;person1的原型有sayName属性吗？&amp;ldquo;答：&amp;ldquo;有。&amp;ldquo;于是，他就读取那个保存在原型对象中的函数。当我们调用person2.sayName()时，将会重现相同的搜索过程，得到相同的结果。而正是多个对象实例共享原型所保存的属性和方法的基本原理
  注意事项 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性
function Person() {} Person.prototype.name = &amp;#39;Nicholas&amp;#39; Person.prototype.age = 19 Person.prototype.sayName = function () { console.</description>
    </item>
    
    <item>
      <title>JavaScript-闭包</title>
      <link>https://damuwangs.github.io/posts/javascript-%E9%97%AD%E5%8C%85/</link>
      <pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/javascript-%E9%97%AD%E5%8C%85/</guid>
      <description>概念   变量的作用域 要理解闭包，首先必须理解Javascript特殊的变量作用域
变量的作用域无非就是两种：全局变量和局部变量
Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量
var n=999 function f1(){ alert(n) } f1() // 999 在函数外部无法读取函数内的局部变量
function f1(){ var n=999 } alert(n); // error   闭包的描述 闭包就是能够读取其他函数内部变量的函数
由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成&amp;quot;定义在一个函数内部的函数&amp;rdquo;
所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁，f2函数，就是闭包
function f1(){ var n=999 function f2(){ alert(n) } return f2 } var result = f1() result() // 999   闭包优缺点 优点：
  希望一个变量长期驻扎在内存中
  避免全局变量的污染
  私有成员的存在
  缺点：闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗
  应用场景   匿名自执行函数 我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包</description>
    </item>
    
    <item>
      <title>2021-面试总结</title>
      <link>https://damuwangs.github.io/posts/2021-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/2021-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
      <description>JavaScript   跨域 概念：跨域指浏览器同源策略不允许当前页面所在的源去请求另一个源的数据只要协议，端口，域名中有一个不同就是跨域
解决：
 服务端更改header，允许跨域 设置代理服务器 因为客户端请求服务端的数据是存在跨域问题的，而服务器和服务器之间 可以相互请求数据，是没有跨域的概念（如果服务器没有设置禁止跨域的权限问题），也就是说，可以配置一个代理的服务器请求另一个服务器中的数据，然后把请求出来的数据返回到代理服务器中，代理服务器再返回数据给客户端，这样就可以实现跨域访问数据 jsonp 利用script标签的src属性来实现跨域。 通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。       get、post区别  get参数url可见，post参数url不可见 通过拼接url进行传递参数，post通过body体传递参数 get请求可以缓存，post请求不可以缓存 get请求页面后退时不产生影响、post请求页面后退时会重新提交请求 get一般传输数据大小不超过2k-4k，post请求传输数据的大小可配置       数据类型   单类型：String、Number、boolean、null、undefined
  引用类型：object、function、array、Date、RegExp
       值传递和引用传递   基本类型复制后两个变量完全独立，一方改变都不会影响另一方
  引用类型复制的时引用，之后的任何一方改变都会映射到另一方
       闭包 定义：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了父函数内部的变量，且返回的这个函数在外部被执行，就产生了闭包。说白了就是一个函数，能够读取其它函数的内部变量
优点：
 读取函数内部的变量 变量长期保存在内存中，不会再外层函数调用后被自动清除 避免全局变量的污染  缺点：常驻内存会增大内存使用量，使用不当会造成内存泄漏</description>
    </item>
    
    <item>
      <title>GitHub Pages&#43;Hugo构建个人博客</title>
      <link>https://damuwangs.github.io/posts/github-pages&#43;hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/github-pages&#43;hugo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>hugo配置 1、安装   下载地址：https://github.com/gohugoio/hugo/releases
  我使用的版本：  解压后即可使用hugo命令，不过只能在当前文件夹下使用，所以需要配置环境变量
  2、配置环境变量   在系统变量Path后面追加一条，为hugo.exe的解压地址我的在D盘
D:\hugo_0.83.1_Windows-64bit   3、项目创建   通过hugo命令创建站点目录并切换到该目录
hugo new site hugo-blog cd hugo-blog 目录结构如下，此时如果运行的话浏览器会白屏，因为此时只是一个空的站点需要下载主题后才能看到内容
  4、主题配置   主题网站：https://themes.gohugo.io/
  我用的是这个主题：https://github.com/AmazingRise/hugo-theme-diary
  选好主题一般都会直接指向GitHub仓库，下载zip到本地就行
  将下载好的主题解压移动到项目目录下的themes文件夹
  配置站点根目录下的config.toml文件
我用的主题里面有作者提供的实例网站配置，把里面的内容复制到站点根目录的config.toml就完美运行了
这里需要注意config.toml配置的theme名称必须和themes下的文件夹名称保持一致
具体hugo的配置还没仔细研究，本篇就简单介绍一下大体的搭建流程，以后可能会写一篇hugo配置/开发相关的
  5、本地预览   启动 Hugo 预览服务器，构建站点内容到内存中并在检测到文件更改后重新渲染
hugo server   6、内容发布   在站点目录下有一个content文件夹，在该文件夹下创建一个posts，posts下创建.md格式的文章就可以自动识别发布了
  同理图片静态资源需要放在站点根目录static下，内容中图片引用也是以static为根目录进行读取的</description>
    </item>
    
  </channel>
</rss>