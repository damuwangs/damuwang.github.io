<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on DaMuWang</title>
    <link>https://damuwangs.github.io/categories/javascript/</link>
    <description>Recent content in JavaScript on DaMuWang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Sep 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://damuwangs.github.io/categories/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JavaScript-异步解决方案</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>概念 Javascript语言的执行环境是&amp;quot;单线程&amp;rdquo;。也就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务。
这种模式虽然实现起来比较简单，执行环境相对单纯，但是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。
为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步和异步
同步 所有的任务都处在同一队列中，不可以插队，一个任务执行完接着开始执行下一个，相对于浏览器而言，同步的效率过低
异步 将一个任务放入到异步队列中，当这个任务执行完成之后，再从异步队列中提取出来，插队到同步队列中，拿到异步任务的结果，可以提升代码执行的效率，不需要因为一个耗时长的代码而一直等待
回调函数 ajax(url, () =&amp;gt; { // 处理逻辑 }) 假设多个请求存在依赖性，可能就会写出如下代码：
ajax(url, () =&amp;gt; { // 处理逻辑  ajax(url1, () =&amp;gt; { // 处理逻辑  ajax(url2, () =&amp;gt; { // 处理逻辑  }) }) }) 优点：解决了同步的问题
缺点：回调地狱，不能用 try catch 捕获错误，不能 return
事件监听 这种方式下，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生
下面是两个函数f1和f2，编程的意图是f2必须等到f1执行完成，才能执行
f1方法执行完，通过$emit发送一个事件doSomething（vue写法）
f1(){ // ...  // 发送事件  this.$emit(&amp;#39;doSomething&amp;#39;, {data:&amp;#39;data&amp;#39;}) } 通过$on接收事件
// 接收事件 this.$on(doSomething, (res) =&amp;gt; { if (res) { this.</description>
    </item>
    
    <item>
      <title>JavaScript-this指向</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-this%E6%8C%87%E5%90%91/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-this%E6%8C%87%E5%90%91/</guid>
      <description>this的指向  在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象
 看几个简单的例子:this指向
改变this的指向 var name = &amp;#34;windowsName&amp;#34;; var a = { name : &amp;#34;Cherry&amp;#34;, func1: function () { console.log(this.name) }, func2: function () { setTimeout( function () { this.func1() },100) } } a.func2() // this.func1 is not a function 在不使用箭头函数的情况下，是会报错的，因为最后调用setTimeout的对象是 window，但是在 window 中并没有 func1 函数
我们在改变 this 指向这一节将把这个例子作为 demo 进行改造
箭头函数 先看箭头函数和普通函数的重要区别：
 1、没有自己的this、super、arguments和new.target绑定
2、不能使用new来调用
3、没有原型对象
4、不可以改变this的绑定
5、形参名称不能重复
 箭头函数的 this 始终指向函数定义时的 this，而非执行时，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”</description>
    </item>
    
    <item>
      <title>JavaScript-EventLoop事件循环</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid>
      <description>概念 JavaScript 是一门单线程语言，即同一时间只能执行一个任务，即代码执行是同步并且阻塞的
 举例：这就像只有一个窗口的银行，客户需要一个一个排队办理业务
 只能同步执行肯定是有问题的，所以 JS 有了一个用来实现异步的函数：setTimeout
Event Loop 就是为了确保 异步代码 可以在 同步代码 执行后继续执行的
队列（Queue） 队列是一种FIFO(First In, First Out) 的数据结构，它的特点就是先进先出
 举例：生活中最常见的例子就是排队，排在队伍最前面的人最先被提供服务
 栈（Stack） 栈是一种 LIFO（Last In, First Out）的数据结构，特点即后进先出
 样例：大家都吃过桶装薯片吧~薯片在包装的时候只能从顶部放入，而吃的时候也只能从顶部拿出，这就叫后进先出
 调用栈（Call Stack） 调用栈本质上当然还是个栈，关键在于它里面装的东西，是一个个待执行的函数
Event Loop 会一直检查 Call Stack 中是否有函数需要执行，如果有，就从栈顶依次执行。同时，如果执行的过程中发现其他函数，继续入栈然后执行
先拿两个函数来说：
 栈空 现在执行到一个函数A，函数A入栈 函数A 又调用了函数B，函数B入栈 函数B执行完后出栈 然后继续执行函数A，执行完后A也出栈 栈空  看一段代码：
const bar = () =&amp;gt; console.log(&amp;#39;bar&amp;#39;) const baz = () =&amp;gt; console.log(&amp;#39;baz&amp;#39;) const foo = () =&amp;gt; { console.</description>
    </item>
    
    <item>
      <title>JavaScript-事件冒泡、事件捕获和事件委托</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</guid>
      <description>事件流 事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题
&amp;lt;div id=&amp;#34;outer&amp;#34;&amp;gt; &amp;lt;p id=&amp;#34;inner&amp;#34;&amp;gt;Click me!&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; 上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？
为了解决这个问题微软和网景提出了两种几乎完全相反的概念
事件冒泡 概念 微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象
样例：事件冒泡 阻止事件冒泡 事件的对象有一个stopPropagation()方法可以阻止事件冒泡，我们只需要把上个例子中button的事件处理程序修改如下：
document.getElementById(&amp;#34;button&amp;#34;).addEventListener(&amp;#34;click&amp;#34;,function(event){ alert(&amp;#34;button&amp;#34;) event.stopPropagation() },false) 事件捕获 概念 网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素
样例：事件捕获 阻止事件捕获 但是我们可以使用DOM3级新增事件stopImmediatePropagation()方法来阻止事件捕获，另外此方法还可以阻止事件冒泡。应用如下
document.getElementById(&amp;#34;second&amp;#34;).addEventListener(&amp;#34;click&amp;#34;,function(event){ alert(&amp;#34;second&amp;#34;) event.stopImmediatePropagation() },true) 那么 stopImmediatePropagation() 和 stopPropagation()的区别在哪儿呢？
后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生
事件委托 在实际的开发当中，利用事件流的特性，我们可以使用一种叫做事件代理的方法
样例 &amp;lt;ul class=&amp;#34;color_list&amp;#34;&amp;gt; &amp;lt;li&amp;gt;red&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;orange&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;yellow&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;green&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;blue&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;purple&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;div class=&amp;#34;box&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; .color_list{ display: flex; display: -webkit-flex; } .color_list li{ width: 100px; height: 100px; list-style: none; text-align: center; line-height: 100px; } //每个li加上对应的颜色，此处省略 .</description>
    </item>
    
    <item>
      <title>JavaScript-跨域</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Wed, 04 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E8%B7%A8%E5%9F%9F/</guid>
      <description>概述 含义 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策
最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页&amp;quot;同源&amp;rdquo;
所谓&amp;quot;同源&amp;quot;指的是&amp;quot;三个相同&amp;rdquo;
  协议相同 域名相同 端口相同   常见跨域场景
目的 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。
设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？
很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制
由此可见，&amp;ldquo;同源政策&amp;quot;是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了
限制范围   Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送   解决方案 CORS CORS 即是指跨域资源共享。它允许浏览器向非同源服务器，发出 Ajax 请求，从而克服了 Ajax 只能同源使用的限制。这种方式的跨域主要是在后端进行设置
这种方式的关键是后端进行设置，即是后端开启 Access-Control-Allow-Origin 为*或对应的origin就可以实现跨域
cors.html
let xhr = new XMLHttpRequest() xhr.open(&amp;#39;GET&amp;#39;, &amp;#39;http://localhost:8002/request&amp;#39;) xhr.send(null) server.js
const express = require(&amp;#39;express&amp;#39;) const app = express() app.use((req, res, next) =&amp;gt; { res.</description>
    </item>
    
    <item>
      <title>JavaScript-防抖、节流</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</link>
      <pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</guid>
      <description>防抖 概念 任务频繁触发的情况下，只有任务触发的间隔超过制定的时间间隔的时候，任务才会被执行
将一段时间内连续的多次触发转化为一次触发。
应用场景   用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询ajax请求，这样可以有效减少请求次数，节约请求资源；
  window的resize、scroll事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次；
  实例   非立即执行版 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;ie=edge&amp;#34;&amp;gt; &amp;lt;title&amp;gt;防抖&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button id=&amp;#34;debounce&amp;#34;&amp;gt;点我防抖！&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; window.onload = function() { // 1、获取这个按钮，并绑定事件  var myDebounce = document.getElementById(&amp;#34;debounce&amp;#34;); myDebounce.addEventListener(&amp;#34;click&amp;#34;, debounce(sayDebounce)); } // 2、防抖功能函数，接受传参  function debounce(fn) { // 4、创建一个标记用来存放定时器的返回值  let timeout = null; return function() { // 5、每次当用户点击/输入的时候，把前一个定时器清除  clearTimeout(timeout); // 6、然后创建一个新的 setTimeout，  // 这样就能保证点击按钮后的 interval 间隔内  // 如果用户还点击了的话，就不会执行 fn 函数  timeout = setTimeout(() =&amp;gt; { fn.</description>
    </item>
    
    <item>
      <title>JavaScript-原型链</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <description>原型   理解原型对象 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。
使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中
function Person() {} Person.prototype.name = &amp;#39;Nicholas&amp;#39; Person.prototype.age = 19 Person.prototype.sayName = function () { console.log(this.name) } let person1 = new Person() person1.sayName() // 输出：Nicholas  let person2 = new Person() person2.sayName() // 输出：Nicholas  console.log(person1.sayName == person2.sayName) // 输出：true 我们将sayName()方法和所有属性直接添加到Person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName()函数
创建了自定义构造函数之后，其原型对象默认只会取得constructor属性，至于其它方法，则都是从Object继承而来。当调用构造函数创建一个新实例后，该实例内部将包含一个指针（内部属性）____proto____指向构造函数的原型对象，需要明确的是，这个连接存在与实例和构造函数的原型之间，而不是存在与实例与构造函数之间
上图展示了Person构造函数、Person的原型属性以及Person现有两个实例之间的关系。在此，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其它属性。Person的每个实例person1和person2都包含一个内部属性____proto____，该属性仅仅指向了Person.prototype，换句话说，它们与构造函数没有直接关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName。这是通过查找对象属性的过程来实现的
  原型搜索机制 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象的实例本身开始。如果在实例中找到了具有给定名字的实现，则返回该属性的值，如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person.sayName()的时候，会先后执行两次搜索。首先，解析器会问：&amp;ldquo;实例person1有sayName属性吗？&amp;ldquo;答：&amp;ldquo;没有。&amp;ldquo;然后，它继续搜索，再问：&amp;ldquo;person1的原型有sayName属性吗？&amp;ldquo;答：&amp;ldquo;有。&amp;ldquo;于是，他就读取那个保存在原型对象中的函数。当我们调用person2.sayName()时，将会重现相同的搜索过程，得到相同的结果。而正是多个对象实例共享原型所保存的属性和方法的基本原理
  注意事项 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性
function Person() {} Person.prototype.name = &amp;#39;Nicholas&amp;#39; Person.prototype.age = 19 Person.prototype.sayName = function () { console.</description>
    </item>
    
    <item>
      <title>JavaScript-闭包</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E9%97%AD%E5%8C%85/</link>
      <pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/javascript-%E9%97%AD%E5%8C%85/</guid>
      <description>概念   变量的作用域 要理解闭包，首先必须理解Javascript特殊的变量作用域
变量的作用域无非就是两种：全局变量和局部变量
Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量
var n=999 function f1(){ alert(n) } f1() // 999 在函数外部无法读取函数内的局部变量
function f1(){ var n=999 } alert(n); // error   闭包的描述 闭包就是能够读取其他函数内部变量的函数
由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成&amp;quot;定义在一个函数内部的函数&amp;rdquo;
所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁，f2函数，就是闭包
function f1(){ var n=999 function f2(){ alert(n) } return f2 } var result = f1() result() // 999   闭包优缺点 优点：
  希望一个变量长期驻扎在内存中
  避免全局变量的污染
  私有成员的存在
  缺点：闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗
  应用场景   匿名自执行函数 我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包</description>
    </item>
    
  </channel>
</rss>