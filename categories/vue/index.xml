<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>VUE on DaMuWang</title>
    <link>https://damuwangs.github.io/categories/vue/</link>
    <description>Recent content in VUE on DaMuWang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 06 Jul 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://damuwangs.github.io/categories/vue/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Vue3-Teleport</title>
      <link>https://damuwangs.github.io/posts/vue3-teleport/</link>
      <pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/vue3-teleport/</guid>
      <description>概念  Teleport 是一种能够将我们的模板移动到 DOM中Vue app之外的其他位置的技术，就有点像哆啦A梦的“任意门”
场景：像 modals,toast 等这样的元素，很多情况下，我们将它完全的和我们的 Vue 应用的 DOM完全剥离，管理起来反而会方便容易很多
原因在于如果我们嵌套在Vue的某个组件内部，那么处理嵌套组件的定位、z-index和样式就会变得很困难
另外，像 modals，toast等这样的元素需要使用到 Vue组件的状态（data或者props）的值
这就是Teleport派上用场的地方。我们可以在组件的逻辑位置写模板代码，这意味着我们可以使用组件的data或props。然后在Vue应用的范围之外渲染它
 Teleport 的使用 index.html中
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;teleport-target&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;module&amp;#34; src=&amp;#34;/src/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; src/components/HelloWorld.vue中，添加如下，留意to属性跟上面的id选择器一致
&amp;lt;button @click=&amp;#34;showToast&amp;#34; class=&amp;#34;btn&amp;#34;&amp;gt;打开 toast&amp;lt;/button&amp;gt; &amp;lt;!-- to 属性就是目标位置 --&amp;gt; &amp;lt;teleport to=&amp;#34;#teleport-target&amp;#34;&amp;gt; &amp;lt;div v-if=&amp;#34;visible&amp;#34; class=&amp;#34;toast-wrap&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;toast-msg&amp;#34;&amp;gt;我是一个 Toast 文案&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/teleport&amp;gt; import { ref } from &amp;#39;vue&amp;#39;; export default { setup() { // toast 的封装  const visible = ref(false); let timer; const showToast = () =&amp;gt; { visible.</description>
    </item>
    
    <item>
      <title>Vue3-组合式API</title>
      <link>https://damuwangs.github.io/posts/vue3-%E7%BB%84%E5%90%88%E5%BC%8Fapi/</link>
      <pubDate>Mon, 05 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/vue3-%E7%BB%84%E5%90%88%E5%BC%8Fapi/</guid>
      <description>概念  通过创建 Vue 组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而随着项目的扩大，功能越来越复杂，定义的数据以及对其数据的操作被放在不同的地方，如methods，watch，碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块，于是出现了组合式api
 组合式api主要解决的问题就是单业务逻辑代码单文件处理，将一个巨大无比的组件分成无数小的文件模块每个模块只处理很少的业务，通过定义setUp选项，将单逻辑的变量、生命周期以及方法独立成JS，再通过export的方式将需要使用的暴漏出来。Vue3提供的响应式API基本上可以保证我们在JS中实现响应式变量、父子组件传值、生命周期等所有操作，这是其它方式所不具备的
为什么要使用组合式 API   组件化的缺点 使用 (data、computed、methods、watch) 组件选项来组织逻辑通常都很有效。然而，当我们的组件开始变得更大时，逻辑关注点的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解
这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块
  提取公共JS方式的缺点 因为无法获取vue对象，只能编写非业务代码，例如工具方法
  插槽的缺点  配置最终出现在模板中，理想情况下，模板应仅包含我们要呈现的内容 公开的属性仅在模板中可用    mixin方式的缺点 mixin的解决方案是将vue页面的js部分提取成公共的以供多个相似模块的共用。这种方式的缺点主要由以下几点
 如methods,components等，选项会被合并，键冲突的组件会覆盖混入对象的，比如混入对象里有个方法A，组件里也有方法A，这时候在组件里调用的话，执行的是组件里的A方法 不可知，不易维护因为你可以在mixins里几乎可以加任何代码，props、data、methods、各种东西，就导致如果不了解mixins封装的代码的话，是很难维护的    样例 说明 实现了一个简单的列表功能，包括：列表展示、查看更多、关键字搜索
   文件名称 功能描述     app.vue 主页，引入列表和搜索组件   app.js 主页面逻辑，包含：1、初始化列表2、加载更多（接收子组件事件）3、关键字搜索（接收子组件事件）   panel.vue 列表组件：接收列表数据渲染数据   panel.js 列表组件逻辑：1、加载更多（emit发送事件）   search.vue 搜索组件：点击搜索框切换选中样式，输入关键字刷新列表数据   search.js 搜索组件逻辑：1、点击搜索框样式切换，自动聚集2、搜索值监听(emit发送事件)    代码 app.</description>
    </item>
    
    <item>
      <title>Vue2-nextTick</title>
      <link>https://damuwangs.github.io/posts/vue2-nexttick/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/vue2-nexttick/</guid>
      <description>概念  官方文档说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
 异步解析  Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新
 ​	简而言之，异步接信息的运行机制如下
 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack） 主线程之外，还存在一个&amp;quot;任务队列&amp;rdquo;（task queue）。只要异步任务有了运行结果，就在&amp;quot;任务队列&amp;quot;之中放置一个事件 一旦&amp;quot;执行栈&amp;quot;中的所有同步任务执行完毕，系统就会读取&amp;quot;任务队列&amp;rdquo;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行 主线程不断重复上面的第三步  事件循环说明 简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新
//改变数据 vm.message = &amp;#39;changed&amp;#39; //想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新 console.log(vm.$el.textContent) // 并不会得到&amp;#39;changed&amp;#39;  //这样可以，nextTick里面的代码会在DOM更新后执行 Vue.nextTick(function(){ console.log(vm.$el.textContent) // 可以得到&amp;#39;changed&amp;#39; })   本次更新循环
 首先修改数据，这是同步任务。同一事件循环的所有同步任务都在主线程上执行，形成一个执行栈，此时还未设计DOM Vue开启一个异步队列，并缓冲再次事件循环中发生的所有数据改变。如果同一个watcher被多次执行，只会被推入到队列中一次    下次更新循环
 同步任务执行完毕，开始执行异步watcher队列的任务，更新DOM。Vue在内部尝试对异步队列使用原生的Promise.then和messageChannel方法，如果执行环境不支持，会采用setTimeOut(fn,0)代替    下次更新循环结束之后
此时通过Vue.nextTick获取到改变后的DOM。通过setTimeOut(fn,0)也可以同样获取到
  简单总结事件循环：
 同步代码执行 查找异步队列，推入执行栈，执行Vue.nextTick[事件1] 查找异步队列，推入执行栈，执行Vue.nextTick[事件2]  总之，异步是单独的一个tick，不会和同步在同一个tick里发生，也是DOM不会马上改变的原有</description>
    </item>
    
    <item>
      <title>Vue2-刷新组件</title>
      <link>https://damuwangs.github.io/posts/vue2-%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/vue2-%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6/</guid>
      <description>刷新组件 provide、inject 结合 v-if 这对选项需要一起使用，以允许一个根组件向其所有子组件注入一个依赖，实现原理就是通过控制router-view 的显示与隐藏，来重渲染路由区域，重而达到页面刷新的效果，show -&amp;gt; false -&amp;gt; show
  修改app.vue，利用 v-if 可以刷新页面的属性，同时使用 provide 和 inject 将祖先节点的数据传递给子代节点
&amp;lt;template&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;router-view v-if=&amp;#34;isRouterAlive&amp;#34;&amp;gt;&amp;lt;/router-view&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { name: &amp;#39;App&amp;#39;, provide (){ return { reload:this.reload } }, data(){ return { isRouterAlive:true } }, methods:{ reload (){ this.isRouterAlive = false this.$nextTick(function(){ this.isRouterAlive = true }) } } } &amp;lt;/script&amp;gt;   在要刷新的子路由页面引入inject,然后执行reload事件即可刷新页面
export default { inject:[&amp;#39;reload&amp;#39;], data() { return {} }, methods: { reflesh(){ this.</description>
    </item>
    
  </channel>
</rss>