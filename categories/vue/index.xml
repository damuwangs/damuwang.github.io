<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>VUE on DaMuWang</title>
    <link>https://damuwangs.github.io/categories/vue/</link>
    <description>Recent content in VUE on DaMuWang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Feb 2022 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://damuwangs.github.io/categories/vue/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【待补充】Vue2-权限控制</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</guid>
      <description>概念  官方文档说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
 参考资料  Vue.nextTick 的原理和用途
 </description>
    </item>
    
    <item>
      <title>【待补充】Vue2-框架搭建</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</guid>
      <description>概念  官方文档说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
 参考资料  Vue.nextTick 的原理和用途
 </description>
    </item>
    
    <item>
      <title>【待补充】Vue3-和Vue2的区别</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-%E5%92%8Cvue2%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-%E5%92%8Cvue2%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>优势 不同  官方文档说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
 参考资料  Vue.nextTick 的原理和用途
 </description>
    </item>
    
    <item>
      <title>Vue2-响应式原理</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 13 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</guid>
      <description>概述 Vue采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式，
监听属性变化
 Vue在初始化的时候，对data对象进行遍历，在这个方法中会调Observe（监听器，观察者）对用户的数据进行监听 在observe中对数据进行判断，对对象进行循环，使用defineReactive，它是vue中的一个核心方法，用来定义响应式 defineReactive方法中实例化了一个Dep（发布者），通过Object.defineProperty对数据进行拦截，把这些 property 全部转为 getter/setter。get数据的时候，通过dep.depend触发Watcher（订阅者）的依赖收集，收集订阅者；set时，会对数据进行比较，如果数据发生了变化会通过dep.notify发布通知，通知Watcher，更新视图  解析指令
  Vue在初始化时传入当前Vue实例和html根节点的元素标识，进行模板解析
  首先会取出模板元素将其转化成fragment编译后统一进行dom挂载，这样做比较高效（此为虚拟dom）
  循环从fragment取出所有元素子节点，进行指令类型判断（以v-text为例），传入指令类型和属性值调用update方法
  update方法中会将视图与vue实例的data属性绑定渲染页面数据。
当data属性值发生变化会被defineReactive监听到，然后通知wctaher绑定新的数据更新视图
  代码 template &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;!-- 双向绑定 --&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; v-model=&amp;#34;name&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; 监听属性变化 初始化vue时会传入一个json格式的对象
let vue = new Vue({ el: &amp;#39;#app&amp;#39;, data: { name: &amp;#34;name&amp;#34;, } }) 取出该对象并遍历data数据，使用Object.defineProperty()方法来监听每一个属性的变化
observe(value){ if (!value || typeof value !== &amp;#39;object&amp;#39;) { return } //遍历data  Object.keys(value).forEach(key =&amp;gt;{ this.defineReactive(value,key,value[key]) // 代理data中的属性到vue实例上  this.</description>
    </item>
    
    <item>
      <title>Vue2-路由传参，页面刷新后参数类型改变</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E5%90%8E%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%94%B9%E5%8F%98/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E5%90%8E%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%94%B9%E5%8F%98/</guid>
      <description>问题描述 今天发现一个小问题，列表通过路由传递的 number 类型参数，用 === 来判断
Number(this.$route.query.type) !== 1 结果发现有时候为 true ，有时候为 false
进入页面，打印参数类型：
number 刷新页面，打印参数类型：
string 后来发现，原因是：
 vue-router 传参，不管是 params 形式还是query形式传参，在页面刷新后，params 和 query 对象中的属性所对应的属性值都会被浏览器自身强制转换为string类型 (这一点与浏览器的sessionStorage和localStorage存储对象，对象会被转为string类型，不谋而合)，破环原先属性值的数据类型
 解决方案 将参数强制转为 Number类型：
Number(this.$route.query.type) 总结 1、number数据类型：页面刷新后，其类型会转换为 string 类型。
所以，在路由刷新页面，在使用时，不管页面是否刷新，都对传递过来的属性值做一次Number()转换；
2、string数据类型：页面刷新后，其类型依然为string类型；
3、boolean数据类型：页面刷新后，其类型会转换为string类型。
所以，在路由刷新页面，在使用时，不管页面是否刷新，都对传递过来的属性值做一次Boolean()转换；
4、undefined数据类型：页面刷新后，其类型依然为undefined类型；
5、null数据类型：页面刷新后，其类型依然为null类型；
6、object数据类型：页面刷新后，其类型会转换为string类型；
所以，在路由跳转传参页面对属性值做一次JSON.stringify()预处理，然后在路由刷新页面对该值进行JSON.parse()转换。
参考资料  vue 路由传参，页面刷新后参数类型改变_且听风吟的博客-CSDN博客
 </description>
    </item>
    
    <item>
      <title>Vue2-token</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-token/</link>
      <pubDate>Fri, 06 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-token/</guid>
      <description>token的含义  1、Token的引入： Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。
2、Token的定义： Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。
3、使用Token的目的： Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。
4、Token 的优点： 扩展性更强，也更安全点，非常适合用在 Web 应用或者移动应用上。Token 的中文有人翻译成 “令牌”，我觉得挺好，意思就是，你拿着这个令牌，才能过一些关卡。
 项目中使用token 说明
   文件名称 功能描述     auth.js 设置、获取以及清空cookie   http.js 接口请求封装   store.js 对接业务的状态管理，负责登录、登出状态的保存和移除    流程梳理
  用户输入信息点击登录，调用store.js中的Login方法请求登录接口，调用成功返回200回传token值
  接着调用SaveLoginInfo方法，将token值state中保存一份，再调用setToken将token在cookie中也保存一份
因为vuex刷新页面数据会丢，所以在cookie里面也放了一份，使用的时候只需要通过getter方法获取state就可以，state默认值为调用getToken获取的cookie中的token值
  此时token对象就可以全局使用了，除登录以外的所有接口请求都要传token，否则会报505错误
  token由服务端生成，设置了失效时间为24小时
当token过期，前端再发送请求，服务端会返回505，此响应会被http.js的拦截器捕获
捕获后先弹框提示‘登录信息已过期，请重新登录&amp;rsquo;，接着调用store.js中的ClearLoginInfo方法清空state中全局token，再调用removeToken移除cookie
  清空完之后会执行跳转，重新回到登录页面重复步骤一
  退出登录与登录操作类似，用户点击退出登录按钮，调用store.js里的ClearLoginInfo方法。先清空state中全局token，再调用removeToken移除cookie
  代码
auth.js
import Cookies from &amp;#39;js-cookie&amp;#39; const TokenKey = &amp;#39;sxmanage-auth-token&amp;#39;// tokenKey为固定字符串  // 根据TokenKey获取cookie中的token信息 export function getToken () { return Cookies.</description>
    </item>
    
    <item>
      <title>Vue3-Teleport</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-teleport/</link>
      <pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-teleport/</guid>
      <description>概念  Teleport 是一种能够将我们的模板移动到 DOM中Vue app之外的其他位置的技术，就有点像哆啦A梦的“任意门”
场景：像 modals,toast 等这样的元素，很多情况下，我们将它完全的和我们的 Vue 应用的 DOM完全剥离，管理起来反而会方便容易很多
原因在于如果我们嵌套在Vue的某个组件内部，那么处理嵌套组件的定位、z-index和样式就会变得很困难
另外，像 modals，toast等这样的元素需要使用到 Vue组件的状态（data或者props）的值
这就是Teleport派上用场的地方。我们可以在组件的逻辑位置写模板代码，这意味着我们可以使用组件的data或props。然后在Vue应用的范围之外渲染它
 Teleport 的使用 index.html中
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;teleport-target&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;module&amp;#34; src=&amp;#34;/src/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; src/components/HelloWorld.vue中，添加如下，留意to属性跟上面的id选择器一致
&amp;lt;button @click=&amp;#34;showToast&amp;#34; class=&amp;#34;btn&amp;#34;&amp;gt;打开 toast&amp;lt;/button&amp;gt; &amp;lt;!-- to 属性就是目标位置 --&amp;gt; &amp;lt;teleport to=&amp;#34;#teleport-target&amp;#34;&amp;gt; &amp;lt;div v-if=&amp;#34;visible&amp;#34; class=&amp;#34;toast-wrap&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;toast-msg&amp;#34;&amp;gt;我是一个 Toast 文案&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/teleport&amp;gt; import { ref } from &amp;#39;vue&amp;#39;; export default { setup() { // toast 的封装  const visible = ref(false); let timer; const showToast = () =&amp;gt; { visible.</description>
    </item>
    
    <item>
      <title>Vue3-组合式API</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-%E7%BB%84%E5%90%88%E5%BC%8Fapi/</link>
      <pubDate>Mon, 05 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue3-%E7%BB%84%E5%90%88%E5%BC%8Fapi/</guid>
      <description>概念  通过创建 Vue 组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而随着项目的扩大，功能越来越复杂，定义的数据以及对其数据的操作被放在不同的地方，如methods，watch，碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块，于是出现了组合式api
 组合式api主要解决的问题就是单业务逻辑代码单文件处理，将一个巨大无比的组件分成无数小的文件模块每个模块只处理很少的业务，通过定义setUp选项，将单逻辑的变量、生命周期以及方法独立成JS，再通过export的方式将需要使用的暴漏出来。Vue3提供的响应式API基本上可以保证我们在JS中实现响应式变量、父子组件传值、生命周期等所有操作，这是其它方式所不具备的
为什么要使用组合式 API   组件化的缺点 使用 (data、computed、methods、watch) 组件选项来组织逻辑通常都很有效。然而，当我们的组件开始变得更大时，逻辑关注点的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解
这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块
  提取公共JS方式的缺点 因为无法获取vue对象，只能编写非业务代码，例如工具方法
  插槽的缺点  配置最终出现在模板中，理想情况下，模板应仅包含我们要呈现的内容 公开的属性仅在模板中可用    mixin方式的缺点 mixin的解决方案是将vue页面的js部分提取成公共的以供多个相似模块的共用。这种方式的缺点主要由以下几点
 如methods,components等，选项会被合并，键冲突的组件会覆盖混入对象的，比如混入对象里有个方法A，组件里也有方法A，这时候在组件里调用的话，执行的是组件里的A方法 不可知，不易维护因为你可以在mixins里几乎可以加任何代码，props、data、methods、各种东西，就导致如果不了解mixins封装的代码的话，是很难维护的    样例 说明 实现了一个简单的列表功能，包括：列表展示、查看更多、关键字搜索
   文件名称 功能描述     app.vue 主页，引入列表和搜索组件   app.js 主页面逻辑，包含：1、初始化列表2、加载更多（接收子组件事件）3、关键字搜索（接收子组件事件）   panel.vue 列表组件：接收列表数据渲染数据   panel.js 列表组件逻辑：1、加载更多（emit发送事件）   search.vue 搜索组件：点击搜索框切换选中样式，输入关键字刷新列表数据   search.js 搜索组件逻辑：1、点击搜索框样式切换，自动聚集2、搜索值监听(emit发送事件)    代码 app.</description>
    </item>
    
    <item>
      <title>Vue2-nextTick</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-nexttick/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-nexttick/</guid>
      <description>概念  官方文档说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
 异步解析  Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新
 ​	简而言之，异步接信息的运行机制如下
 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack） 主线程之外，还存在一个&amp;quot;任务队列&amp;rdquo;（task queue）。只要异步任务有了运行结果，就在&amp;quot;任务队列&amp;quot;之中放置一个事件 一旦&amp;quot;执行栈&amp;quot;中的所有同步任务执行完毕，系统就会读取&amp;quot;任务队列&amp;rdquo;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行 主线程不断重复上面的第三步  事件循环说明 简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新
//改变数据 vm.message = &amp;#39;changed&amp;#39; //想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新 console.log(vm.$el.textContent) // 并不会得到&amp;#39;changed&amp;#39;  //这样可以，nextTick里面的代码会在DOM更新后执行 Vue.nextTick(function(){ console.log(vm.$el.textContent) // 可以得到&amp;#39;changed&amp;#39; })   本次更新循环
 首先修改数据，这是同步任务。同一事件循环的所有同步任务都在主线程上执行，形成一个执行栈，此时还未设计DOM Vue开启一个异步队列，并缓冲再次事件循环中发生的所有数据改变。如果同一个watcher被多次执行，只会被推入到队列中一次    下次更新循环
 同步任务执行完毕，开始执行异步watcher队列的任务，更新DOM。Vue在内部尝试对异步队列使用原生的Promise.then和messageChannel方法，如果执行环境不支持，会采用setTimeOut(fn,0)代替    下次更新循环结束之后
此时通过Vue.nextTick获取到改变后的DOM。通过setTimeOut(fn,0)也可以同样获取到
  简单总结事件循环：
 同步代码执行 查找异步队列，推入执行栈，执行Vue.nextTick[事件1] 查找异步队列，推入执行栈，执行Vue.nextTick[事件2]  总之，异步是单独的一个tick，不会和同步在同一个tick里发生，也是DOM不会马上改变的原有</description>
    </item>
    
    <item>
      <title>Vue2-刷新组件</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/vue2-%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6/</guid>
      <description>刷新组件 provide、inject 结合 v-if 这对选项需要一起使用，以允许一个根组件向其所有子组件注入一个依赖，实现原理就是通过控制router-view 的显示与隐藏，来重渲染路由区域，重而达到页面刷新的效果，show -&amp;gt; false -&amp;gt; show
  修改app.vue，利用 v-if 可以刷新页面的属性，同时使用 provide 和 inject 将祖先节点的数据传递给子代节点
&amp;lt;template&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;router-view v-if=&amp;#34;isRouterAlive&amp;#34;&amp;gt;&amp;lt;/router-view&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { name: &amp;#39;App&amp;#39;, provide (){ return { reload:this.reload } }, data(){ return { isRouterAlive:true } }, methods:{ reload (){ this.isRouterAlive = false this.$nextTick(function(){ this.isRouterAlive = true }) } } } &amp;lt;/script&amp;gt;   在要刷新的子路由页面引入inject,然后执行reload事件即可刷新页面
export default { inject:[&amp;#39;reload&amp;#39;], data() { return {} }, methods: { reflesh(){ this.</description>
    </item>
    
  </channel>
</rss>