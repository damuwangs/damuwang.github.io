<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>React on DaMuWang</title>
    <link>https://damuwangs.github.io/categories/react/</link>
    <description>Recent content in React on DaMuWang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 09 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://damuwangs.github.io/categories/react/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【待补充】React-Hook</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-hook/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-hook/</guid>
      <description>为什么需要Portals Portals能够将子组件渲染到父组件以外的DOM树，他通常用于子组件需要从父组件的容器中脱离出来的场景，有以下场景：
参考资料  传送门：React Portal
你真的了解React Portals吗
 </description>
    </item>
    
    <item>
      <title>【待补充】React-RenderProps</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-renderprops/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-renderprops/</guid>
      <description>为什么需要Portals Portals能够将子组件渲染到父组件以外的DOM树，他通常用于子组件需要从父组件的容器中脱离出来的场景，有以下场景：
参考资料  传送门：React Portal
你真的了解React Portals吗
 </description>
    </item>
    
    <item>
      <title>React-Portals</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-portals/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-portals/</guid>
      <description>为什么需要Portals Portals能够将子组件渲染到父组件以外的DOM树，他通常用于子组件需要从父组件的容器中脱离出来的场景，有以下场景：
 Dialog对话框 Tooltip文字提示 Popover弹出框 Loader全局loader  比如某个组件在渲染时，在某种条件下需要显示一个Dialog，最直观的做法，就是直接在JSX中把Dialog画出来，像下面代码的样子
&amp;lt;div class=&amp;#34;foo&amp;#34;&amp;gt; &amp;lt;div&amp;gt; ... &amp;lt;/div&amp;gt; { needDialog ? &amp;lt;Dialog /&amp;gt; : null } &amp;lt;/div&amp;gt; 问题是，Dialog最终渲染产生的HTML就与上面JSX产生的HTML产生嵌套了，类似下面这样
&amp;lt;div class=&amp;#34;foo&amp;#34;&amp;gt; &amp;lt;div&amp;gt; ... &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;dialog&amp;#34;&amp;gt;Dialog Content&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 对于对话框应该是一个独立的组件，通常应该显示在屏幕的最中间，现在Dialog被包在其它组件中，要用CSS的position属性控制Dialog位置，就要从Dialog往上一直到body都没有其它position是relative的元素干扰。还有一点，Dialog的样式，因为包含在其它元素中，各种样式纠缠，CSS样式太容易搞成一坨浆糊了。
我们既希望在组件的JSX中选择使用Dialog，把Dialog用的像普通组件一样，但是又希望Dialog内容显示在另一个地方，就需要Portals上场了。
Portals就是建立一个“传送门”，让Dialog这样的组件在表示层和其它组件没有任何差异，但是渲染的东西却像经过传送门一样出现在另一个地方
当我们需要在正常的DOM结构之外呈现子组件时，React Portals非常有用，而不需要通过React组件树层次结构破坏事件传播的默认行为，这在渲染例如弹窗、提示时非常有用
React v16的Portals支持 在某个组件中需要使用modal弹框，大多数情况下可以使用fixed定位让这个弹框全局展示，但是特殊情况下，这个modal弹框可能会显示不正常。这个时候如果使用了portals的方式，使modal的dom结构脱离父组件的容器，就可以规避这种问题
// 定义弹框组件 const Modal = ({message, isOpen, onClose, children}) =&amp;gt; { if (!isOpen) return null // 创建portals并挂载到body中  return ReactDOM.createPortal( &amp;lt;div className=&amp;#34;modal&amp;#34;&amp;gt; &amp;lt;span&amp;gt;{message}&amp;lt;/span&amp;gt; &amp;lt;button onClick={onClose}&amp;gt;Close&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; , document.body) } // 弹框使用 function Component() { const [open, setOpen] = useState(false) return ( &amp;lt;div className=&amp;#34;component&amp;#34;&amp;gt; &amp;lt;button onClick={() =&amp;gt; setOpen(true)}&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;Modal message=&amp;#34;Hello World!</description>
    </item>
    
    <item>
      <title>React-高阶组件</title>
      <link>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://damuwangs.github.io/posts/%E7%BC%96%E7%A8%8B/react-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</guid>
      <description>概念 一个高阶组件只是一个包装了另外一个React组件的React组件
基础高阶组件 装饰器模式 高阶组件可以看做是装饰器模式(Decorator Pattern)在React的实现。即允许向一个现有的对象添加新的功能，同时又不改变其结构，属于包装模式(Wrapper Pattern)的一种
// 定义高阶组件 const withHeader = (WrappedComponent) =&amp;gt; class extends React.Component { render() { return ( &amp;lt;div&amp;gt; &amp;lt;div className=&amp;#34;demo-header&amp;#34;&amp;gt;高阶组件&amp;lt;/div&amp;gt; &amp;lt;WrappedComponent {...this.props}/&amp;gt; &amp;lt;/div&amp;gt; ) } } // 调用高阶组件 @withHeader class Demo extends React.Component { render() { return ( &amp;lt;div&amp;gt;普通组件&amp;lt;/div&amp;gt; ) } } 组件命名 当通过高阶组件来包装一个组件时，你会丢失原先 WrappedComponent 的名字，可能会给开发和 debug 造成影响
我们改写一下上述的高阶组件代码，增加了getDisplayName函数以及静态属性displayName，此时再去观察DOM Tree
// 获取组件名称 function getDisplayName(component) { return component.displayName || component.name || &amp;#39;Component&amp;#39; } // 定义高阶组件 const withHeader = WrappedComponent =&amp;gt; class extends React.</description>
    </item>
    
  </channel>
</rss>
